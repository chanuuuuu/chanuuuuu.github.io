{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n&nbsp;&nbsp;지난 포스팅을 통해 JS에서 날짜 및 시간 데이터를 전달할 문자열은 ISO 8601 형식에 맞춰 사용하기로 하였다. 이제 이 문자열을 데이터베이스에 저장하고자 한다. 하지만 MySQL에서 사용할 수 있는 날짜 및 시간 데이터의 저장 형식은 5가지나 될뿐더러 각 형식에서 사용할 수 있는 문자열의 형식과 ISO 8601의 형식이 다르기 때문에 그대로 사용하기 어렵다. ISO 8601 형식의 문자열에 적합한 저장 형식을 고려하면서 이번 기회에 항상 헷갈렸던 MySQL의 날짜 및 시간 데이터 저장방식을 정리해보았다. <span class='small-text'>**관계형 데이터베이스의 데이터를 다루기 위해서 데이터베이스 관리 시스템(DBMS)을 사용하는데 그 중, MySQL을 기준으로 설명한다.</span>\r\n\r\n\r\n# MySQL의 날짜 및 시간 데이터 형식 (Data Type)\r\n\r\n&nbsp;&nbsp;MySQL은 날짜 및 시간 데이터를 5가지의 형식으로 저장한다. 각 형식에 대한 차이와 사용 가능한 문자열을 설명하고자 한다. <span class='small-text'>(숫자를 통한 표현도 가능하지만 여기서는 문자열 형식에 집중하였다.)</span>기본 예제는 '2020-03-20 03:30:58'을 사용한다.\r\n\r\n## 예제환경\r\n\r\n&nbsp;&nbsp;각 날짜 및 시간 데이터의 형식을 테스트하기 위해 각 형식의 컬럼을 가진 테이블을 생성하였다. 테이블의 DDL과 생성된 테이블의 컬럼을 아래에 제시하였다.\r\n\r\n```SQL\r\nDROP TABLE  IF EXISTS `type_test`;\r\n\r\nCREATE TABLE `type_test` (\r\n  `mytimestamp` timestamp,\r\n  `mydate` date,\r\n  `mytime` time,\r\n  `mydatetime` datetime,\r\n  `myyear` year\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\r\n```\r\n![](date_table.png)\r\n\r\n<br/>\r\n\r\n## DATE\r\n---\r\n\r\n&nbsp;&nbsp;날짜 정보를 저장한다. 사용 가능한 형식은 두 가지이다. 반드시 날짜의 의미를 가진 숫자를 사용해야 한다. \r\n### 1. 'YYYY-MM-DD' 의 형식 \r\n\r\n구분자를 사용한 년 - 월 - 일 데이터 형식이다. 아래와 같은 특징을 가진다. \r\n- __구분자 '-'에 대신 다른 특수 문자로 대체가 가능하다.__  \r\n  </br>\r\n- __년 / 월 / 일의 숫자 모두 날짜의 의미를 지니는 숫자여야 한다. 각각의 유효 범위는 아래와 같다.__  \r\n\r\n    ***(년 / 월 / 일 모두 0은 포함되지 않는다.)***\r\n\r\n    - 'YYYY'의 유효 범위는 [0001, 9999]\r\n    - 'MM'의 유효 범위는 [01, 12]\r\n    - 'DD'의 유효 범위는 [01, 31]\r\n\r\n```SQL\r\n# OK!\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-03-20');\r\n\r\n# OK!\r\nINSERT INTO `type_test` (mydate) VALUES ('2020%03%21');\r\nINSERT INTO `type_test` (mydate) VALUES ('2021~03~22');\r\n\r\n# Incorrect date value: '2020-03-32' for column 'mydate' at row 1\r\n# 32일은 날짜의 의미를 가지지 못한다.\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-03-32');\r\n\r\n# Incorrect date value: '2020-13-01' for column 'mydate' at row 1\r\n# 13월은 날짜의 의미를 가지지 못한다.\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-13-01');\r\n\r\n#Incorrect date value: '2020-01-00' for column 'mydate' at row 1\r\n# 년 / 월 / 일 모두 0은 사용이 불가능하다.\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-01-00');\r\n```\r\n<br/>\r\n\r\n### 2. 구분자가 생략된 'YYYYMMDD' 형식\r\n위의 형식에서 구분자가 생략된 형식이다. 구분자를 사용하지 않기 때문에 문자열의 길이를 줄일 수 있으나 자릿 수에 따라 시간적 의미가 달라질 수 있으므로 주의하여야 한다.\r\n```SQL\r\n# OK!\r\nINSERT INTO `type_test` (mydate) VALUES ('20210320');\r\n\r\n# Incorrect date value: '20201301' for column 'mydate' at row 1\r\n# 13월은 날짜의 의미를 가지지 못한다.\r\nINSERT INTO `type_test` (mydate) VALUES ('20201301');\r\n\r\n# 2069-03-20이 저장된다.\r\nINSERT INTO `type_test` (mydate) VALUES ('690320');\r\n\r\n# 1970-03-20이 저장된다.\r\nINSERT INTO `type_test` (mydate) VALUES ('700320');\r\n```\r\n-  __네 자리 표현 'YYYY'으로 사용된 년도를 두 자리 표현 'YY' 이 사용 가능하다__  \r\n두 자리 표현은 표현 범위의 제약으로 필자는 사용하지 않는다. 사용하려면 [표현 범위 제약 조건](https://dev.mysql.com/doc/refman/8.0/en/two-digit-years.html)에 대해 올바르게 이해하고 사용하자. \r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n## TIME\r\n---\r\n&nbsp;&nbsp;시간 정보를 저장한다. 여러 가지 형식이 존재하지만, 기본적인 형식만 설명하고 이외의 형식은 예제로 소개만 하였다. DATE와 동일하게 반드시 시간의 의미를 가진 숫자를 사용해야 한다.\r\n\r\n### 1. 기본적인 시,분,초로 구성된 'hh:mm:ss' 형식\r\n\r\n구분자를 사용한 시:분:초 데이터 형식이다. 아래와 같은 특징을 가진다. \r\n\r\n- __시 / 분 / 초 각각의 유효 범위는 아래와 같다.__\r\n    - 'hh'의 유효 범위는 [00, 23]\r\n    - 'mm'의 유효 범위는 [00, 60]\r\n    - 'ss'의 유효 범위는 [00, 60]  \r\n    </br>\r\n- __기본 형식 'hh:mm:ss'에서 일의 수인 'D'를 추가하여 'D hh:mm:ss'를 사용할 수 있다.__     \r\n  &nbsp;&nbsp;&nbsp;&nbsp;'D'는 [0, 34] 사이의 값을 가지며, 1일당 24시간씩 더해져서 TIME 형식으로 저장된다.   \r\n  위의 예제에서는 4일이므로 24*4인 96시간이 더해져 99시간으로 저장된다.  \r\n    </br>\r\n- __부분 형식 또한 사용이 가능하다.__   \r\n그중 하나인 'hh:mm' 형식을 예제에서 확인할 수 있다.\r\n\r\n```SQL\r\n# 'hh:mm:ss' 형식, OK!\r\nINSERT INTO `type_test` (mytime) VALUES ('03:30:58');\r\n\r\n# Incorrect time value: '03:60:58' for column 'mytime' at row 1\r\nINSERT INTO `type_test` (mytime) VALUES ('03:60:58');\r\n\r\n# 'D hh:mm:ss' 형식, OK! '99:30:58'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('4 03:30:58');\r\n\r\n# 'hh:mm' 형식, OK! '03:30:00'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('03:30');\r\n```\r\n\r\n<br/>\r\n\r\n### 2. 구분자가 존재하지 않는 'hhmmss' 형식\r\n\r\n\r\n- 예제에서처럼 구분자가 존재하지 않는 문자열의 경우, 자릿수가 증가할수록 인식하는 형식이 달라지기 때문에 주의하여야 한다.\r\n\r\n```SQL\r\n# 'hhmmss' 형식, OK! '03:30:58'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('033058');\r\n\r\n# 'mmss' 형식, OK! '00:03:30'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('0330');\r\n\r\n# 'ss' 형식, OK! '00:00:08'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('8');\r\n\r\n# 'ss' 형식, Incorrect time value: '80' for column 'mytime' at row 1\r\nINSERT INTO `type_test` (mytime) VALUES ('80');\r\n\r\n# 'mmss' 형식, OK! '00:08:00'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('800');\r\n\r\n# 'mmss' 형식, Incorrect time value: '8000' for column 'mytime' at row 1\r\nINSERT INTO `type_test` (mytime) VALUES ('8000');\r\n\r\n# 'hhmmss' 형식, OK! '08:00:00'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('80000');\r\n```\r\n- <span class='sub-text'>** TIME 형식의 경우, 정밀도를 위해 소수 초를 지원한다. 'hh:mm:ss.fraction' 의 형식으로 최대 6자리까지의 소수를 지원하며 소수 초을 사용하기 위해서는 TIME 형식을 선언할 때, DATE(6) 과 같이 자릿수를 명시한다.</span>\r\n\r\n\r\n<br/>\r\n<br/>\r\n\r\n## DATETIME\r\n---\r\n&nbsp;&nbsp;날짜 및 시간 정보를 저장한다. 위의 DATE 형식과 TIME 형식을 함께 사용한 `'<DATE>T<TIME>'`의 형식을 사용한다. \r\n\r\n- __날짜와 시간을 'T'를 통해 구분하며, 구분자 대신 공백을 사용할 수 있다. `'<DATE> <TIME>'`__  \r\n    </br>\r\n- __`<DATE>`는 위의 DATE 형식의 설명과, `<TIME>`는 위의 TIME 형식의 설명과 동일하다.__  \r\n    \r\n    1. 년 / 월 / 일 / 시 / 분 / 초 모두 각 날짜와 시간의 의미를 가지는 유효 범위 내에 존재하여야 한다.  \r\n    2. 'YYYY-MM-DD hh:mm:ss', 'YYYYMMDDhhmmss', 'YYYYMMDDThhmmss' 의 형식이 사용가 능하다. (하지만 'YYYYMMDD hhmmss' 의 형식은 불가능하다.)\r\n    3. TIME 형식과 동일하게 소수 초를 지원하며 소수 초을 사용하기 위해서는 TIME 형식을 선언할 때, `DATETIME(6)`와 같이 자릿수를 명시한다.   \r\n   <br/>   \r\n\r\n- __오프셋의 명시가 가능하다.__    \r\n  \r\n    &nbsp;&nbsp;명시된 오프셋이 계산된 '2020-03-20 11:30:58'이 저장된다. TIMESTAMP 형식과 동일하게 시간대를 반영하여 저장되는데, 아래의 TIMESTAMP 형식의 설명을 통해 이해할 수 있다.  \r\n    <br/>\r\n\r\n- __위의 설명을 통해 DATETIME 형식에는 우리가 사용하고자 했던 '2020-03-20T03:30:58Z'은 삽입이 불가능하다는 것을 알 수 있다.__\r\n\r\n```SQL\r\n# 'YYYY-MM-DDThh:mm:ss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20T03:30:58');\r\n\r\n# 'YYYY-MM-DD hh:mm:ss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20 03:30:58');\r\n\r\n# ISO 8601 형식, Data truncation: Incorrect datetime value\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20T03:30:58Z');\r\n\r\n# 'YYYYMMDDThhmmss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('20200320T033058');\r\n\r\n# 'YYYYMMDD hhmmss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('20200320 033058');\r\n\r\n# 오프셋 명시 형식,  '2020-03-20 11:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20T03:30:58+01:00');\r\n```\r\n\r\n<br/>\r\n<br/>\r\n\r\n\r\n## TIMESTAMP\r\n---\r\n\r\n&nbsp;&nbsp;DATETIME과 동일하게 날짜 및 시간 정보를 저장하며 사용할 수 있는 문자열 형식 또한 \r\n`<DATE>T<TIME>` ,  `<DATE> <TIME>`으로 동일하다. 하지만 중요한 __두 가지 차이점__이 존재한다.\r\n\r\n### 1. 시간 의미의 차이\r\n\r\n&nbsp;&nbsp;전달되는 날짜 및 시간 문자열을 그대로 저장하는 DATETIME와 달리 TIMESTAMP 형식은 UTC 시간으로의 변환을 거친 뒤 저장한다. 이러한 변환 과정이 두 형식의 차이를 만드는데, 변환 과정을 '2020-03-20 03:30:58'로 예를 들어 설명한다.\r\n\r\n1. __데이터베이스의 환경변수로 설정된 time_zone(시간대)을 통해 해당 지역의 오프셋을 정의한다.__    \r\n   - 아래의 코드를 통해 현재 데이터베이스가 사용하는 시간대를 확인할 수 있다.\r\n    ```SQL\r\n    SELECT @@time_zone; // SYSTEM\r\n    SELECT @@system_time_zone; //KST\r\n    ```\r\n    </br>\r\n  \r\n   - `@@time_zone` 은 MySQL이 사용하는 시간대로, 'SYSYEM'의 값은 현재 시간대가 설정되지 않았으며, MySQL을 실행하는 OS의 시간대를 사용한다는 의미를 가진다. `SET @@time_zone = '+1';` 와 같이 SET을 통해 특정 시간대를 설정할 수 있다.  \r\n  <br/>  \r\n\r\n   - `@@system_time_zone`은 MySQL을 실행하는 OS의 시간대를 의미한다.\r\n\r\n    <br/>      \r\n\r\n2. __날짜 및 시간 데이터를 정의된 오프셋을 사용하여 UTC 시간으로 변환하여 저장한다.__   \r\n    \r\n   &nbsp;&nbsp;현재 데이터베이스가 사용하는 시간대가 'KST'이므로 오프셋은 '+9'이다.   \r\n   내부적으로는 '2020-03-20 03:30:58'으로 저장하는 것이 아닌,  \r\n    오프셋을 반대로 연산하여 변환된 UTC 시간인 '2020-03-19 18:30:58'UTC 로 저장된다.   \r\n    <br/>\r\n3. __조회 시에 현재 데이터베이스의 오프셋을 사용하여 UTC 시간으로 저장되어있는 날짜 및 시간 데이터를 지역 시간으로 바꿔 반환한다.__\r\n\r\n    &nbsp;&nbsp;TIMESTAMP 형식은 데이터 조회시마다 내부 변환 과정을 거친 데이터를 보여주기 때문에 일반적으로 DATETIME과 차이가 나지 않는다. 하지만 행 추가 시점과 조회 시점의 시간대가 변경되는 경우에 그 차이가 나타난다. 아래 코드의 결과를 통해 이해해보자.\r\n    ```SQL\r\n    DELETE FROM type_test;\r\n\r\n    // SYSTEM = KST = '+09:00'\r\n    SELECT @@time_zone; \r\n\r\n    INSERT INTO type_test(mydatetime, mytimestamp) \r\n    VALUES ('2020-03-20 03:30:58', '2020-03-20 03:30:58');\r\n\r\n    SELECT mydatetime, mytimestamp FROM type_test;\r\n    # +-------------------------------------------+\r\n    # |      mydatetime     |      mytimestamp    |\r\n    # |-------------------------------------------|\r\n    # | 2020-03-20 03:30:58 | 2020-03-20 03:30:58 |\r\n    # +-------------------------------------------+\r\n\r\n    SET @@time_zone = '+01:00';\r\n\r\n    SELECT mydatetime, mytimestamp FROM type_test;\r\n    # +-------------------------------------------+\r\n    # |      mydatetime     |      mytimestamp    |\r\n    # |-------------------------------------------|\r\n    # | 2020-03-20 03:30:58 | 2020-03-19 19:30:58 |\r\n    # +-------------------------------------------+\r\n    ```\r\n    <br/>\r\n    &nbsp;&nbsp;삽입 시점의 데이터베이스의 시간대는 KST으로, 오프셋은 '+9'이다. 시간대를 변경하기 전 조회 시점의 경우, 동일한 시간대, 동일한 오프셋이기 때문에 두 형식 모두 '2020-03-20 03:30:58'을 출력하는 것을 볼 수 있다. TIMESTAMP는 삽입 시점의 오프셋인 '+9'를 고려한 '2020-03-19 18:30:58'UTC 을 저장해두었다. 이후, 조회 시점의 오프셋 또한 '+9'로 동일하기 때문에 DATETIME과 동일한 '2020-03-20 03:30:58'을 반환한다. 하지만 시간대가 변경되고 난 후 TIMESTAMP 형식의 결과는 조회 시점의 시간대를 반영하기 때문에 '2020-03-19 18:30:58'UTC에 조회 시점의 오프셋인 '+1'을 연산한 '2020-03-19 19:30:58'을 반환하게 된다.  \r\n\r\n</br>\r\n\r\n### 2. 표현 범위의 차이\r\n\r\n&nbsp;&nbsp;두 번째 차이점인 표현 범위의 차이는 저장 방식의 차이이기도 한데, __TIMESTAMP는 UTC 시간으로 변환하여 저장할 때, 유닉스 시간으로 저장한다.__   \r\n\r\n___'유닉스 시간이란, UTC 시간의 시작시간인 '1970-01-01 00:00:00'UTC 로부터의 경과 시간을 UTC 초를 나타내는 4 바이트 정수를 의미한다.'___\r\n\r\n&nbsp;&nbsp;TIMESTAMP는 단순히 '2020-03-20 03:30:58'을 UTC 시간으로 변환한 '2020-03-19 18:30:58'UTC를 저장하는 것이 아닌, __'1970-01-01 00:00:00'UTC 부터 '2020-03-19 18:30:58'UTC 까지의 초 수인 $1,584,610,258$ 을 저장한다.__ 이러한 저장방식은 아래의 특징들과 같은 표현 범위의 차이를 만든다.\r\n\r\n\r\n- __유닉스 시간으로 저장되는 TIMESTAMP는 시작 시간인 '1970-01-01 00:00:00'UTC 에서부터만 표현이 가능하다.__   \r\n    &nbsp;&nbsp;&nbsp;&nbsp;UNIX_TIMESTAMP() 함수를 통해 유닉스 시간으로 변환해볼 수 있는데, '1970-01-01 00:00:00'UTC 이전의 날짜를 변환하면 모두 0의 값을 가진다.   \r\n\r\n    ```SQL\r\n    // 0\r\n    SELECT UNIX_TIMESTAMP('1970-01-01 00:00:00'); \r\n\r\n    // 1584610258\r\n    SELECT UNIX_TIMESTAMP('2020-03-20 03:30:58');\r\n\r\n    // 0\r\n    SELECT UNIX_TIMESTAMP('1945-08-15 00:00:00'); \r\n    ```\r\n    </br>\r\n- __TIMESTAMP는 4바이트 정수라는 한계로 인해 $2,147,483,647(2^{31}- 1)$ 초까지만 표현이 가능하다.__  (이를 'Y2K38', [2038년 문제](https://ko.wikipedia.org/wiki/2038%EB%85%84_%EB%AC%B8%EC%A0%9C)라고 한다.)  \r\n    &nbsp;&nbsp;&nbsp;&nbsp;실제로 유닉스 시간을 지역 시간으로 변환하는 함수인 `FROM_UNIXTIME()`으로 계산을 해보면 '2038-01-19 03:14:07'UTC, 한국 시각으로는 '2038-01-19 12:14:07'까지만 표현이 가능한 것을 확인할 수 있다. 표현 범위의 한계를 넘어선 2,147,483,648초를 변환해보면 NULL이 반환된다.  \r\n\r\n    ```SQL\r\n    // '2038-01-19 12:14:07', '2038-01-19 03:14:07'UTC\r\n    SELECT FROM_UNIXTIME(2147483647, '%Y-%m-%d %h:%i:%s');\r\n\r\n    // NULL\r\n    SELECT FROM_UNIXTIME(2147483648, '%Y-%m-%d %h:%i:%s');\r\n    ```\r\n    </br>\r\n\r\n&nbsp;&nbsp;DATETIME, TIMESTAMP의 표현 범위 차이를 정리하면,    \r\n  - __DATETIME은  &nbsp;&nbsp;&nbsp;['0000-01-01 00:00:00', '9999-12-31 23:58:59']__\r\n  - __TIMESTAMP는 ['1970-01-01 00:00:00', '2038-01-19 03:14:07']__  \r\n\r\n&nbsp;&nbsp;하지만 UTC 시간을 따르는 TIMESTAMP는 시간대에 따라, 명시한 오프셋에 따라 그 범위가 다르다.  \r\n또한 날짜 및 시간 데이터를 저장할 때는 표현 범위 밖의 데이터는 저장되지 않는다. 아래의 예제로 확인해보자.\r\n\r\n```SQL\r\n# Data truncation: Incorrect datetime value: '1970-01-01 00:00:01' for column\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('1970-01-01 00:00:00');\r\n\r\n# Data truncation: Incorrect datetime value: '1970-01-01 09:00:00' for column\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('1970-01-01 09:00:00');\r\n\r\n# OK! '1970-01-01 09:00:01'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('1970-01-01 09:00:01');\r\n\r\n# OK! '2020-03-20 11:30:58'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('2038-01-19 12:14:08+01:00');\r\n\r\n# OK! '2038-01-19 12:14:07'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('2038-01-19 12:14:07');\r\n\r\n# Data truncation: Incorrect datetime value: '2038-01-19 12:14:08'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('2038-01-19 12:14:08');\r\n```\r\n\r\n&nbsp;&nbsp;예제와 같이 __한국의 시간대를 사용하여 삽입할 때, 표현 범위는 지역의 오프셋을 고려한 범위인 ['1970-01-01 09:00:01', '2038-01-19 12:14:07']이 된다.__ 또한 오프셋을 명시한 '2038-01-19 12:14:08+01:00'도 가능한데, 위의 설명과 동일하기 때문에 '2020-03-20 11:30:58'의 값을 가지는 이유에 대해서는 스스로 이해해보자.\r\n\r\n</br>\r\n</br>\r\n\r\n# 결론\r\n\r\n## DATETIME vs TIMESTAMP\r\n---\r\n\r\n&nbsp;&nbsp;두 형식을 정리해보자면, \r\n  - 두 형식에 사용 가능한 문자열의 형식은 동일하며, 지역 지정자 'Z'가 추가된 문자열은 사용이 불가능하다.\r\n  - DATETIME은 __UTC를 고려하지 않고 지역 시간으로 저장__한다.\r\n  - TIMESTAMP는 __UTC를 반영하여 내부적으로 UTC 시간으로 저장해두고 조회 시에 지역 시간으로 변환한다.__ 이를 통해 조회하는 지역마다 동일한 UTC 시간을 의미할 수 있도록 다르게 표현한다.\r\n  \r\n<span class='small-text'>** 년도 정보를 저장하는 YEAR 형식도 존재한다. 자세히 다루지 않고 [링크](https://dev.mysql.com/doc/refman/8.0/en/year.html)로 대체한다.</span>\r\n</br>\r\n\r\n## ISO 8601 형식에 맞는 저장 형식은?\r\n---\r\n&nbsp;&nbsp;지금까지 MySQL에서 날짜 및 시간 데이터를 저장하는 형식에 대해 알아보았다. ISO 8601 형식의 데이터를 어떤 형식으로 저장해야할까? 날짜 데이터를 저장하는 DATE, 시간 데이터를 저장하는 TIME 두 형식 모두 날짜와 시간 데이터의 부분적인 정보만을 담을 수 있기 때문에 DATETIME, TIMESTAMP가 ISO 8601 형식의 데이터를 저장하는 데 적합하다고 볼 수 있다. ISO 8601 형식의 두 가지 경우에 따라 적합한 저장 방식과 전략을 설정해야 한다.\r\n\r\n### 'YYYY-MM-DDThh:mm:ssZ' 형식의 UTC 시간을 사용하는 경우,\r\n\r\n&nbsp;&nbsp;먼저 지역 지정자 'Z'가 추가된 문자열은 사용이 불가능하므로 제거하는 전처리가 필요하다.   \r\n1. DATETIME 형식으로 저장하게 되면 UTC 시간을 고려하지 않기 때문에 UTC 시간의 의미를 그대로 저장할 수 있으므로 __UTC 시간을 저장하길 원한다면 해당 형식을 사용하자.__  \r\n    </br>  \r\n2. TIMESTAMP에 저장하게 되면 해당 시간이 UTC 시간임에도 불구하고 지역 시간대를 고려한 UTC 시간으로 변환하는 작업을 거친 뒤, 저장되게 된다.~~(UTC 시간의 UTC 시간화..)~~   \r\n   &nbsp;&nbsp;&nbsp;&nbsp;물론 삽입과 조회 시점의 시간대가 동일한 경우, 저장한 시간의 값은 동일할 수 있으나 UTC 시간의 의미가 사라지게 된다. 또한 시간대가 변경되면 해당 시간대의 오프셋으로 계산되기 때문에 값이 변경될 수 있다. 그러므로 __TIMESTAMP를 사용하기 위해서는 '+00:00'으로 오프셋을 명시하여 UTC 시간으로 저장될 수 있도록 하자.__ \r\n\r\n</br>\r\n\r\n### 'YYYY-MM-DDThh:mm:ss' 형식의 지역 시간을 사용하는 경우, \r\n\r\n1. DATETIME 형식으로 저장하게 되면 UTC 시간을 고려하지 않기 때문에 지역 시간의 의미를 그대로 저장할 수 있으므로 __지역 시간을 저장하길 원한다면 해당 형식을 사용하자.__  \r\n    </br>  \r\n2. TIMESTAMP에 저장하게 되면 지역 시간대를 고려한 UTC 시간으로 변환하여 저장하기 때문에 조회하는 지역 시간대를 고려한 지역 시간대를 전달할 수 있다. __하지만 저장하고자 하는 지역 시간의 시간대와 데이터베이스의 시간대가 동일해야 올바른 시간을 전달할 수 있을 것이다.__\r\n\r\n\r\n</br>\r\n</br>\r\n\r\n## 참고자료\r\n---\r\n각 형식별 문자열 형식 [https://dev.mysql.com/doc/date-and-time-literals.html](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html)\r\n\r\n각 형식별 내부 저장 구조 [https://dev.mysql.com/doc/date-and-time-data-type-representation.html](https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html)\r\n\r\n</br></br></br>","excerpt":"지난 포스팅을 통해 JS에서 날짜 및 시간 데이터를 전달할 문자열은 ISO 8601 형식에 맞춰 사용하기로 하였다. 이제 이 문자열을 데이터베이스에 저장하고자 한다. 하지만 MySQL에서 사용할 수 있는 날짜 및 시간 데이터의 저장 형식은 5가지나 …","fields":{"slug":"/date-02/"},"frontmatter":{"date":"Jul 06, 2021","title":"MySQL에서 날짜 및 시간 문자열 저장하기","tags":["DB","DATE"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n&nbsp;&nbsp;날짜 관련 오류가 발생하면 그 때마다 원인을 이해하려고 하기보다 인터넷에서 코드를 긁어와 빠르게 해결하는 것에 집중했었다. \r\n하지만 이번 문제를 접하고, JS에서 날짜를 다루는 것에 대해 정리가 필요할 것 같아 포스팅하게 되었다. \r\n\r\n# 문제 \r\n\r\n&nbsp;&nbsp;Safari 환경에서 JS의 Date 객체를 사용하여 날짜를 보여주는 UI에서 _'Invalid Date'_ 를 뱉어냈다.\r\n\r\n![](invalid_date.png)\r\n\r\nSafari에서 'YYYY-MM-DD hh:mm:ss' (예를 들면 '2020-03-20 03:30:58') 형식의 문자열로 Date 객체를 선언하게 되는 경우 _'Invalid Date'_ 을 반환한다.\r\n\r\n\r\n### JS에서의 Date 객체\r\n\r\n&nbsp;&nbsp;JS에서는 Date 객체를 사용하여 날짜를 표현한다. 현재 시각이 필요한 경우, `new Date().now()` 를 통해 알아내기도 하고, 서버에서 전달받은 날짜 문자열을 `new Date(dateString)`으로 Date 객체를 만들어 시간/일자 연산(예를 들면, 호텔 체크아웃 날짜 계산)을 하는 등 문자열을 통해 날짜와 시간을 표현해야하는 경우에 쉽게 사용할 수 있다. 하지만 예상한 시간과 다르게 반환되거나 위의 경우처럼 아예 `NaN` 이 뜨는 등 갖가지 오류를 접하기도 하는데, 실제로 [Mozlia web docs](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/Date)를 보면 날짜 문자열 파싱 문제를 미리 경고해두었다.\r\n\r\n ___'Date 생성자(및 동일한 동작의 Date.parse())를 사용한 날짜 파싱은 동작이 일관적이지 못하고 브라우저끼리 차이가 존재하므로 사용하지 않는 것이 좋습니다.'___\r\n\r\n&nbsp;&nbsp;실제로 그런지 각 브라우저간의 차이를 확인하기 위해 Safari, Chrome, IE, Edge를 준비하고 각 브라우저의 콘솔창을 통해 결과값을 확인해보았다. ~~(Firefox, Opera 등 다른 웹 브라우저는 과제로 남겨두겠다.)~~ 테스트에 사용된 날짜 문자열  '2020-03-20 03:30:58'은 실제로 사용하고 있는 'YYYY-MM-DD hh:mm:ss' 형식의 dummy data이다.\r\n\r\n\r\n### 브라우저별 Date 객체 선언 테스트\r\n\r\n__1. 테스트 코드__  \r\n&nbsp;&nbsp; `new Date('2020-03-20 03:30:58')`\r\n\r\n#### 2. 테스트 결과   \r\n- safari - 버전 14.0.3(16610.4.3.1.7)\r\n![](safari_test1.png)\r\n<br/>\r\n\r\n- chrome - 버전 91.0.4472.114(공식 빌드) (arm64)\r\n![](chrome_test1.png)\r\n<br/>\r\n\r\n- edge - 버전 91.0.864.59 (공식 빌드) (64비트)\r\n![](edge_test1.png)\r\n<br/>\r\n\r\n- IE - 버전 2004(OS 빌드 19041.985)\r\n![](IE_test1.png)\r\n\r\n&nbsp;&nbsp;동일한 날짜 문자열의 Date 객체를 선언하였음에도 그 결과가 브라우저마다 다른 것을 볼 수 있다. <span class='sub-text'> (**브라우저의 실행 지역, 버전에 따라 결과가 다를 수 있습니다.)</span> 이 테스트를 통해 JS가 수행되는 환경에 따라 Date 객체를 통한 파싱의 결과가 다를 수 있다는 것을 알 수 있었다. 그럼에도 불구하고 서버 측에서 날짜 및 시간에 대한 데이터를 문자열 형태로 전달하기 때문에 브라우저상에서 Date 객체를 통해 날짜를 파싱하는 것이 불가피하였다. 그래서 각기 다른 브라우저에서 동일한 파싱 결과를 보여줄 수 있는 다른 방법을 찾아보았다.\r\n\r\n\r\n# 원인 \r\n\r\n&nbsp;&nbsp;하지만 실제 문제의 원인은 날짜 및 시간 데이터의 전달을 위해 내부적으로 사용하던 'YYYY-MM-DD hh:mm:ss' 형식이 날짜 및 시간 문자열 표준 형식인 ISO 8601을 따르지 않은 것이다. 이로 인해 특정 브라우저에서 날짜에 대한 데이터로 인식되지 못하는 문제가 발생했다. 문제를 해결하기 위해서는 날짜 및 시간 문자열의 표준 형식인 ISO 8601의 개념이 필요하기에 나름대로 요약해보았다. 내가 필요한 부분만 가져왔기 때문에 깊게 알고 싶은 분들은 출처를 참조하자.\r\n\r\n### ISO 8601\r\n> ISO 8601은 날짜와 시간과 관련된 데이터 교환을 다루는 국제 표준이다.\r\n- 날짜표현은  `YYYY-MM-DD` , 시간 표현은 `hh:mm:ss.sss` `hh:mm:ss` 으로 표현되며 구분자는 생략이 가능하다.\r\n- 날짜와 시간 혼합표현은 `<date>T<time>`이다.\r\n- 날짜와 시간은 0을 붙여 고정 자릿수를 유지한다.\r\n- 시간이 UTC인 경우, 시간 뒤에 빈칸없이 Z를 직접 추가해야 한다. Z는 오프셋이 0인 UTC를 위한 지역 지정자(zone designator)다.  `<date>T<time>Z` 가 된다.\r\n\r\n___'인터넷 상에서, World Wide Web Consortium (W3C)는 에러율과 소프트웨어 복잡도를 줄이기 위해 제공된 날짜와 시간 형식을 제한하는 표준 프로파일을 정의하기 위해 ISO 8601를 사용한다.'___\r\n\r\n&nbsp;&nbsp;날짜 및 시간 문자열 형식을 표준에 맞추기 위해서는 'YYYY-MM-DD hh:mm:ss'가 아닌 'YY-MM-DDThh:mm:ssZ' 의 형식을 사용해야 한다. 단순히~~(무지성으로)~~ 날짜와 시간 사이에 'T'를 넣고 맨 마지막에 'Z'가 붙여 표준 형식을 맞추려고 했다면 전혀 다른 날짜 및 시간 정보를 보게 될 것이다. 브라우저가 ISO 8601 문자열로 Date 객체를 생성할 때, __'Z' 문자를 통해 해당 문자열이 표현하는 시간을 오프셋이 0인 UTC 시간으로 인식하기__ 때문이다. 대신, 맨 뒤의 __'Z' 문자를 빼게 되면 해당 문자열이 표현하는 시간을 UTC 시간이 아닌 지역 시간으로 인식하게__ 된다. 갑자기 등장하는 'UTC', '오프셋', '지역 시간'의 개념이 생소할 수 있다. 아래에서 간단히 설명하는데 혹시 자세히 알고 싶다면 [위키](https://ko.wikipedia.org/wiki/%ED%98%91%EC%A0%95_%EC%84%B8%EA%B3%84%EC%8B%9C)를 참조하자.\r\n\r\n- **UTC**\r\n    > GMT(그리니치 평균 시간)로도 불리며, 그리니치 천문대의 시간을 기준으로한 국제 표준시이다.\r\n<br/>\r\n\r\n- **오프셋**\r\n    > 그리니치 천문대의 시간을 기준으로 한 GMT와 지역별의 시간차이를 의미한다.\r\n    - <span class=\"small-text\"> 한국은 +9으로, 즉 그리니치 천문대의 시간보다 9시간이 빠르다.</span>  \r\n<br/>  \r\n\r\n- **지역 시간**\r\n    > GMT를 기준으로 해당 지역의 오프셋, 썸머 타임등을 반영한 시간이다.\r\n    - <span class=\"small-text\"> 현재 이 글에서는 서비스 사용자의 브라우저가 실행되는 지역의 시간을 의미한다. </span>\r\n    - <span class=\"small-text\">  **쉬운 설명을 위해 오프셋에 썸머타임 등, 지역시간에 영향을 주는 변수를 모두 포함하겠다. </span>\r\n\r\n글만으로는 이해하기 어려울 것 같아 각 브라우저, 문자열 형식별 비교를 위해 3개의 코드를 각 브라우저에서 실행시켜보았다. 결과를 보면서 이해해보자.\r\n\r\n### 브라우저/형식별 Date 객체 선언 테스트\r\n\r\n#### 1. 테스트 코드\r\n\r\n1-1. 이전 테스트  \r\n  &nbsp;&nbsp; `new Date('2020-03-20 03:30:58')`  \r\n\r\n\r\n1-2. 단순히 형식을 맞추기 위한 'T', 'Z' 문자 추가  \r\n  &nbsp;&nbsp; `new Date('2020-03-20T03:30:58Z')`  \r\n\r\n1-3. 지역 시간으로 전달하기 위해 'Z' 제거  \r\n  &nbsp;&nbsp; `new Date('2020-03-20T03:30:58')`  \r\n\r\n#### 2. 테스트 결과\r\n- safari - 버전 14.0.3(16610.4.3.1.7)\r\n![](safari_test2.png)\r\n<br/>\r\n\r\n- chrome - 버전 91.0.4472.114(공식 빌드) (arm64)\r\n![](chrome_test2.png)\r\n<br/>\r\n\r\n- edge - 버전 91.0.864.59 (공식 빌드) (64비트)  \r\n![](edge_test2.png)\r\n<br/>\r\n\r\n- IE - 버전 2004(OS 빌드 19041.985)\r\n![](IE_test2.png)\r\n\r\n\r\n&nbsp;&nbsp;`new Date('2020-03-20T03:30:58Z')`의 결과를 살펴보면 한국의 시간 오프셋은 +9이기 때문에 'T', 'Z' 문자가 추가된 Date 객체의 시간은 03시가 아닌 9시간이 더해진 12시가 된다. 하지만 'T' 문자만 추가한 `new Date('2020-03-20T03:30:58')`의 결과에서는 오프셋을 계산할 지역 정보가 존재하지 않기 때문에 지역 시간으로 간주하여 시간이 03시 그대로인 것을 볼 수 있다.\r\n\r\n# 해결\r\n\r\n&nbsp;&nbsp;이번 문제는 날짜 및 시간의 문자열을 표준 형식으로 맞추는 것으로 문제를 해결할 수 있다. 해결하는 방법은 기준 시간대를 UTC 시간으로 할 것인가, 지역 시간으로 할 것인가에 따라 두 가지로 나뉜다. 이해를 돕기 위해 글의 작성시점인 한국 시각 '2021-06-30 13:49:30'를 예로 들어 설명하고자 한다.\r\n\r\n### 1. UTC 시간을 기준으로 포맷팅\r\n\r\n__'기존의 시간에서 지역의 시간 오프셋을 반대로 연산하여 UTC 시간으로 바꿔 전달하여 브라우저가 사용자의 지역시간에 맞게 변경할 수 있도록 한다.'__  \r\n\r\n&nbsp;&nbsp; UTC 시간을 기준으로 전달하기 위해 '2021-06-30 13:49:30'을 한국의 오프셋인 '+9'를 고려하여 9시간을 뺀 '2021-06-30T04:49:30'UTC 로 미리 계산, 포맷팅하여 데이터 베이스나 서버의 내부 데이터로 사용하는 방법이다. __브라우저는 '2021-06-30T04:49:30Z'의 문자열로 Date 객체를 생성할 때 해당 시간을 UTC 시간으로 인식하고 브라우저가 실행되는 지역에 맞게 지역 시간으로 변경한다.__ 한국의 브라우저에서는 9시간이 더해진 '2021-06-30 13:49:30'으로 표현될 것이고, 오프셋이 '+1'인 프랑스의 브라우저에서는 '2021-06-30 05:49:30'으로 표현될 것이다. 이를 통해 지역별 시간대 변환 문제를 해결할 수 있다. 하지만 __지역 시간으로 변경하는 연산을 브라우저에게 의존해야 하기 때문에__ 예기치 않은 문제가 발생할 수 있다는 단점이 있다.<span class='sub-text'>(브라우저 종류, 버전에 따라 달라질 수 있다고 한다.)</span> 또한 국내 시간대만 사용하는 서비스의 경우, 지역 오프셋을 미리 계산하는 포맷팅 과정이 불필요할 수 있다.\r\n\r\n<br/>\r\n\r\n### 2. 지역 시간을 기준으로 포맷팅\r\n\r\n__'지역 시간을 기준으로 전달하기 위해 '2021-06-30 13:49:30'을 '2021-06-30T13:49:30'로 변환하여 데이터 베이스나 서버의 내부 데이터로 사용하는 방법이다.'__\r\n\r\n&nbsp;&nbsp; 지역 시간을 기준으로 전달하기 위해 '2021-06-30 13:49:30'을 '2021-06-30T13:49:30'로 변환하여 데이터 베이스나 서버의 내부 데이터로 사용하는 방법이다. 위의 방법과 달리 __브라우저는 '2021-06-30T13:49:30'의 문자열로 Date 객체를 생성할 때 해당 문자열을 지역 시간으로 인식하고 그대로 '2021-06-30 13:49:30'을 표현한다.__ 국내 시간대만 사용하는 서비스의 경우에는 지역 시간만 사용해도 되기 때문에 바로 적용 가능한 방법이다. __하지만 동일 시간대를 사용하지 않는 다른 지역에서의 접속 시 문제가 발생한다. 해당 지역의 오프셋을 고려하지 않기 때문에 프랑스의 브라우저에서도 동일하게 '2021-06-30 13:49:30'으로 표현된다.__ 같은 시간이 _\"표시됐으니 된 거 아냐?\"_ 할 수 있지만, 전혀 다른 의미를 가진다. 프랑스 브라우저의 시간을 한국 시각으로 계산해보면,   \r\n\r\n1. <span class='small-text'>'2021-06-30 13:49:30'을 UTC 시간으로 변경하면 -1 시간을 한 '2021-06-30 11:49:30'이 된다. </span> \r\n  \r\n2. <span class='small-text'> '2021-06-30 11:49:30'을 한국 시간으로 변경하면 +9 시간을 한 '2021-06-30 20:49:30'이 된다.</span>   \r\n\r\n프랑스의 브라우저가 나타내는 시간은 전혀 다른 '2021-06-30 20:49:30'을 의미하고 있는 것이다! 한국의 브라우저에서는 내가 점심을 먹고 글을 작성하였다면, 프랑스의 브라우저에서는 저녁을 먹고 글을 작성한 것이 된다. 이처럼 여러 시간대의 글로벌한 서비스를 위해서는 단순히 지역 시간으로 제공하는 것이 아닌   '2021-06-30T13:49:30+9',  '2021-06-30T13:49:30+1'과 같이 문자열 끝에 해당 지역의 오프셋을 명시하는 방법을 사용해야 한다. 사실 Date 객체의 `toLocaleString()` 함수를 사용하여 지역 시간대로 변경할 수 있다고 하지만 이 글에서는 문자열에만 집중해보았다.\r\n\r\n<br/>\r\n\r\n### 3. 날짜 관련 라이브러리 사용\r\n\r\n&nbsp;&nbsp;위의 두 가지의 해결 방식은 라이브러리의 사용을 고려하지 않았다. 하지만 라이브러리는 문자열의 형식이나 오프셋 계산등 걱정하지 않고 사용할 수 있도록 많은 기능이 제공된다. 사실상 지금까지의 모든 고민을 해결할 수 있으니 나처럼 고민하지 말고 그냥 사용하자. 추천하는 라이브러리는 _day.js_ 인데 대문부터 크기를 강조하는 것을 보면 다른 날짜 라이브러리보다 가벼운 것은 확실해 보인다. (가벼운 게 최고다.) 함수명이 매우 직관적이라 쉽게 사용할 수 있기 때문에 설명하지 않고 예제와 [docs](https://day.js.org/docs/en/installation/installation) 링크를 남긴다.\r\n\r\n```javascript\r\n// 대충 한국 시간대를 사용하겠다는 코드\r\nimport dayjs\r\nimport LocalizedFormat from 'dayjs/plugin/localizedFormat';\r\nimport relativeTime from 'dayjs/plugin/relativeTime';\r\nimport 'dayjs/locale/ko';\r\n\r\ndayjs.extend(LocalizedFormat);\r\ndayjs.extend(relativeTime);\r\n\r\ndayjs(date).toISOstring()\r\n```\r\n<br/>\r\n\r\n# 요약\r\n\r\n- Date 객체를 사용하여 날짜 및 시간 문자열을 파싱하기 위해서는 표준인 ISO 8601을 따르자. 그래야 브라우저별로 다르게 동작하는 것을 ~~(거의 다)~~ 막을 수 있다.  \r\n   \r\n- 시간대별로 브라우저의 동작이 다를 수 있으니 서비스에 따라 'UTC 시간', '지역 시간' 또는 '오프셋을 명시한 지역시간' 중 적절한 형식을 사용하자.  \r\n  \r\n- 그냥 날짜 관련 라이브러리를 사용하자.\r\n\r\n다음 포스팅에서는 Node.js(NestJS) - MySQL 데이터 베이스에서 날짜 및 시간 문자열을 다루는 것을 정리해보려고 한다. MySQL에서 날짜 및 시간 문자열을 다루는 형식은 또 다르다. 다음 글은 좀 짧으니 시간이 남는다면 읽어보자.\r\n\r\n### 참고 자료\r\n\r\n시간 및 날짜 문자열에 대한 정리 [https://meetup.toast.com/posts/130](https://meetup.toast.com/posts/130)  \r\nISO 8601에 대한 정의 [https://ko.wikipedia.org/wiki/ISO_8601](https://ko.wikipedia.org/wiki/ISO_8601)\r\n\r\n<br/><br/><br/><br/>\r\n","excerpt":"날짜 관련 오류가 발생하면 그 때마다 원인을 이해하려고 하기보다 인터넷에서 코드를 긁어와 빠르게 해결하는 것에 집중했었다. \n하지만 이번 문제를 접하고, JS에서 날짜를 다루는 것에 대해 정리가 필요할 것 같아 포스팅하게 되었다.  문제   Safa…","fields":{"slug":"/date-01/"},"frontmatter":{"date":"Jul 02, 2021","title":"JS에서 날짜 및 시간 문자열 다루기","tags":["JS","DATE"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}