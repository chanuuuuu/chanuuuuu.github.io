{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## InnoDB 주요 장점\r\n\r\n1. 동작을 수행하는 Commit, 동작 수행 이전 상태로 돌아가는 Rollback과 같은 Transaction 기능을 지원한다.\r\n2. Row-level locking과 Consistent reads를 통해 다중 사용자 환경에서 동시 수행이 가능하다.\r\n3. **물리적 저장 기준인 PRIMARY KEY를 통한 Clustered index 기능을 제공한다.**\r\n4. **데이터 무결성을 보장하기 위한 FOREIGN KEY 기능을 제공한다.**  \r\n\r\n\r\n&nbsp;&nbsp;이번 포스팅은 지난 포스팅에 이어서 주요 장점 3, 4번에 대해 다룰 것입니다. 나머지 주요 장점들을 이해하기 위해서 먼저 Index와 Key에 대한 이해가 필요합니다. 그러므로 인덱스를 충분히 설명한 뒤에 장점들에 대해 다루도록 하겠습니다.\r\n\r\n\r\n# Index\r\n---\r\n\r\n&nbsp;&nbsp;데이터의 저장된 위치를 일련의 기준으로 정렬하여 저장한 자료구조를 의미합니다. 인덱스와 테이블의 관계는 아래의 그림과 같습니다.\r\n\r\n![](index_table_struct.png)\r\n\r\n&nbsp;&nbsp;현재 인덱스는 테이블의 첫 번째 컬럼을 기준으로 오름차순 정렬되어있는 것을 볼 수 있습니다. 테이블의 물리적인 저장 순서와는 다르게 인덱스로 지정한 컬럼들의 값을 기준으로 정렬되어있어 **필요한 데이터를 빠르게 찾을 수 있도록 도와주는 역할**을 수행합니다. 또한, 인덱스를 통해 **테이블에 대한 제약조건을 정의**할 수 있습니다. 예를 들어 UNIQUE, PRIMARY 인덱스를 정의함으로써 구성된 컬럼을  조건으로 사용한 조회에 대한 성능 향상뿐만 아니라 모든 행이 다른 값으로 삽입되도록 하는 제약 조건을 통해 데이터 무결성을 확보할 수 있습니다.\r\n\r\n- **KEY**  \r\n    **제약 조건을 정의하는 인덱스를 구성하는 컬럼들의 집합**을 말합니다. 인덱스는 하나 이상의 컬럼을 통해 정의할 수 있으며, SQL문으로 특정 제약조건을 만족하는 컬럼을 키로 가지는 인덱스를 선언하여 제약조건을 정의할 수 있습니다.  \r\n\r\n    ```SQL\r\n    ALTER TABLE index_test ADD CONSTRAINT <인덱스명> PRIMARY KEY (<컬럼명>);\r\n    ```\r\n\r\n<br/>\r\n\r\n## 인덱스를 사용하는 방식\r\n---\r\n\r\n&nbsp;&nbsp;InnoDB가 쿼리를 수행할 때 쿼리문의 조건에 사용할 수 있는 모든 인덱스를 찾습니다. 각 인덱스의 Cardinality에 따라 우선순위가 매겨지고, 가장 적은 행을 탐색할 수 있는 인덱스를 사용합니다. 하지만 인덱스로 정의된 컬럼을 조건으로 사용한다고 해서 모두 빠른 조회를 수행하는 것은 아닙니다. 특히 여러 개의 컬럼을 인덱스로 설정하였을 때, 인덱스를 사용하지 못하는 경우가 많은데요. 아래의 경우를 살펴봅시다.\r\n\r\n\r\n### 다중 컬럼 인덱스\r\n\r\n```SQL\r\nCREATE TABLE index_test (\r\n\tx INT NOT NULL, \r\n\ty INT,\r\n\tz INT\r\n\tINDEX tidx (x, y, z)\r\n) ENGINE = InnoDB;\r\n\r\nINSERT INTO index_test VALUES (2, 3, 2), (4, 1, 3), (1, 2, 5), \r\n\t(5, 2, 4), (3, 2, 1), (4, 3, 2);\r\n```\r\n\r\n&nbsp;&nbsp;**여러 컬럼을 사용하여 인덱스를 정의할 수 있지만 지정하는 컬럼의 순서가 매우 중요합니다.** 인덱스가 여러 개의 컬럼을 키로 가질 때, 각 컬럼을 독립적으로 고려하지 않고 하나의 값으로 간주하므로 **모든 컬럼의 값들을 튜플 화(x, y, z)하여 정렬**합니다. 이러한 방식으로 인해 위의 예제에서 tidx의 인덱스는 아래의 그림과 같이 정렬되어있습니다. <span class='small-text'>(InnoDB의 인덱스는 B-Tree 구조로, 이처럼 단순한 배열 방식은 아니지만, leaf node는 아래의 그림과 같이 동일하게 정렬되어있기 때문에 이해를 돕기 위해 사용하였습니다.)</span>\r\n\r\n![](index_ex1.png)\r\n\r\n&nbsp;&nbsp;정렬 순서를 보면 컬럼 x의 값을 기준으로 먼저 정렬하고 이후에 y, z 컬럼 순의 기준으로 정렬되어있음을 볼 수 있습니다. 이러한 정렬 순서로 인해 2번째 데이터의 y 컬럼의 값이 3번째 데이터의 y 컬럼의 값보다 크지만, 순서상 앞에 있는 것을 볼 수 있습니다. 그렇다면 이제 이러한 인덱스의 정렬 순서가 조회 시에 어떠한 영향을 미치는지 살펴보겠습니다.\r\n\r\n\r\n- __1. 인덱스의 첫번째 컬럼을 사용한 조회__  \r\n    <br/>\r\n    ```SQL\r\n    EXPLAIN SELECT * FROM index_test WHERE x = 4;\r\n    # +---------------------------------------------------------+ \r\n    # |      type     |           key         |      rows       |\r\n    # |----------------------------------------------------------\r\n    # |      ref      |          tidx         |        2        |\r\n    # +---------------------------------------------------------+\r\n    ```\r\n    <br/>\r\n    &nbsp;&nbsp;tidx 인덱스의 첫 번째 컬럼을 사용한 쿼리입니다. 해당 쿼리의 실행계획을 살펴보면, 인덱스를 사용하여 6개의 행 중에 2개의 행만 조회하여 결과를 반환한 것을 확인할 수 있습니다. x 컬럼의 순으로 정렬되어있기 때문에 배열상에서 빠르게 찾을 수 있었습니다. \r\n\r\n<br/>\r\n<br/>\r\n\r\n\r\n- __2. 인덱스의 첫번째 컬럼을 사용하지 않은 조회__  \r\n    <br/>\r\n    ```SQL\r\n    EXPLAIN SELECT * FROM index_test WHERE y = 2;\r\n    # +---------------------------------------------------------+ \r\n    # |      type       |          key        |      rows       |\r\n    # |----------------------------------------------------------\r\n    # |      index      |         tidx        |        6        |\r\n    # +---------------------------------------------------------+\r\n    ```  \r\n    <br/>\r\n\r\n    &nbsp;&nbsp;tidx 인덱스의 두 번째 컬럼만을 사용한 쿼리입니다. 실행 계획을 통해 해당 쿼리가 인덱스를 사용하였으나, 모든 행을 조회하여 결과를 반환한 것을 확인할 수 있습니다. 인덱스로 정의된 컬럼을 사용하였음에도 모든 행을 조회한 이유는 정렬 순서에 있습니다.   \r\n    <br/> \r\n\r\n    ![](index_ex2.png)\r\n\r\n    <br/>\r\n\r\n    &nbsp;&nbsp;첫 번째 쿼리의 결과는 파란색 박스, 두 번째 쿼리의 결과는 빨간색 박스로 표현하였습니다. 첫 번째 컬럼을 사용한 쿼리의 결과는 **순서상 연속된 범위에 존재하며, 이외의 순서에서는 값이 존재하지 않는 것을 보장할 수 있기 때문에 해당 범위 이전과 이후 순서에 대해 탐색할 필요가 없습니다.** 하지만 첫 번째 컬럼을 사용하지 않은 쿼리의 경우, **Y 컬럼의 값이 동일하더라도 X 컬럼의 값에 따라 우선 정렬되기 때문에 쿼리의 결과가 연속되지 않습니다. 이로 인해 첫 번째 컬럼을 사용하지 않은 쿼리는 모든 범위에 대해 탐색할 수밖에 없습니다.** 이러한 컬럼 순서 기반 정렬은 (x, y)와 (x, z) 컬럼을 조건으로 사용하는 경우 또한 동일한 방식으로 조회 범위를 제한합니다. \r\n\r\n    <br/>\r\n\r\n    ```SQL\r\n    # (x, y) 컬럼 사용\r\n    EXPLAIN SELECT * FROM index_test WHERE x = 4 AND y = 3;\r\n    # +---------------------------------------------------------+ \r\n    # |      type     |           key         |      rows       |\r\n    # |----------------------------------------------------------\r\n    # |      ref      |          tidx         |        1        |\r\n    # +---------------------------------------------------------+\r\n\r\n    # (x, z) 컬럼 사용\r\n    EXPLAIN SELECT * FROM index_test WHERE x = 4 AND z = 2;\r\n    # +---------------------------------------------------------+ \r\n    # |      type     |           key         |      rows       |\r\n    # |----------------------------------------------------------\r\n    # |      ref      |          tidx         |        2        |\r\n    # +---------------------------------------------------------+\r\n\r\n    # OR 조건 사용은 범위의 제한이 발생하지 않습니다.\r\n    SELECT * FROM index_test WHERE x = 4 OR y = 4;\r\n    # +---------------------------------------------------------+ \r\n    # |      type       |          key        |      rows       |\r\n    # |----------------------------------------------------------\r\n    # |      index      |         tidx        |        6        |\r\n    # +---------------------------------------------------------+\r\n    ``` \r\n    <br/> \r\n\r\n    &nbsp;&nbsp;추가로, **여러 컬럼의 집합으로 인덱스를 정의할 수 있지만 컬럼의 값을 인덱스로 저장하기 때문에 인덱스의 크기가 매우 커질 수 있습니다.** 인덱스가 커지면 테이블의 크기 또한 커질 뿐만 아니라 성능 저하가 발생할 수 있습니다. 여러 컬럼의 값을 함께 사용하여 조회하는 경우, 여러 컬럼의 값을 사용하여 만든 해시값을 사용한 인덱스를 정의할 수 있습니다. 이럴 때, 단일 컬럼이며 해시값을 통해 인덱스의 크기를 줄일 수 있기 때문에 더 빠른 조회가 가능하게 됩니다.\r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n## 인덱스 저장 구조\r\n---\r\n\r\n&nbsp;&nbsp;지금까지 인덱스를 표현한 그림에서는 단순히 정렬된 배열 형태로 표현되었지만, 실제로 InnoDB의 인덱스는 B-Tree 구조를 가집니다. 비교를 위해 Hash 구조의 인덱스에 대해서도 함께 설명합니다. 하지만 InnoDB는 Hash 구조의 인덱스는 지원하지 않습니다.\r\n\r\n### B-Tree\r\n\r\n![](b_tree.png)\r\n\r\n> **이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조를 의미한다.**\r\n\r\n&nbsp;&nbsp;그림을 보면 이전에 인덱스를 설명한 것과 동일하게 B-Tree의 leaf node는 그 값들이 모두 정렬된 것을 볼 수 있습니다. 하지만 빠르게 조회의 범위를 좁혀나갈 수 있도록 중간 구분 값(또는 저장된 값)들을 부모 노드로 사용합니다. 이러한 트리 구조는 조회, 삽입, 삭제의 시간 복잡도를 log(N)에 수행할 수 있도록 합니다. 예를 들어 컬럼의 값 12를 인덱스를 사용하여 조회하는 것을 생각해봅시다.\r\n\r\n1. 인덱스로 정의된 컬럼을 조건으로 사용하기 때문에 루트 노드 (7, 16)에서 조회를 시작합니다.  \r\n    <br/>\r\n2. 조건의 컬럼값 12가 루트 노드에 존재하는지 확인합니다.     \r\n    <br/>  \r\n3. 존재하지 않기 때문에 이후 X ≤ 7, 7 < X < 16, X ≥ 16의 범위에서 어디에 속하는지 확인합니다.    \r\n    <br/>\r\n4. 7 < X < 16의 범위에 존재하기 때문에 중간의 인덱스가 가리키고 있는 자식 노드로 이동합니다.  \r\n    <br/>\r\n5. 조건의 컬럼값 12가 자식 노드에 존재하는지 확인합니다.   \r\n    <br/>\r\n6. 존재하지 않기 때문에 X ≤ 9, 9 < X < 12, X ≥ 12의 범위에서 어디에 속하는지 확인합니다.  \r\n    <br/>\r\n7. X ≥ 12의 범위에 속하고, 현재의 노드가 leaf node이기 때문에 해당 범위에서부터 순차적으로 탐색하여 12를 찾습니다.  \r\n    \r\n&nbsp;&nbsp;이진 탐색 트리와 유사한 방식으로, 단일 값에 대한 조회뿐 만 아니라 범위를 조건으로 사용하는 조회에 대해서도 효율적입니다. $=$, $>$, $>=$, $<$, $<=$, or `BETWEEN` 연산자에 대해 인덱스를 사용할 수 있습니다.또한 문자열 조회 시, `LIKE` 연산자는 범위에 대한 조회 방식을 사용하기 때문에 해당 연산자 또한 동일하게 인덱스를 사용할 수 있습니다.\r\n\r\n### Hash\r\n\r\n&nbsp;&nbsp;'key- value' 형식의 해쉬 구조로 인덱스를 저장하여 사용합니다. 이러한 구조는 $=$,  $<=>$ 과 같은 동치 비교 연산에 대해 매우 빠르게 동작하지만, 이외의 비교 연산에 대해서는 인덱스가 사용되지 않습니다. 또한 여러 개의 컬럼으로 인덱스를 정의할 수 있지만 사용되는 컬럼의 값을 모두 사용하여 해시값을 만들기 때문에 반드시 정의된 모든 컬럼을 사용한 조회에서만 인덱스를 사용할 수 있습니다.\r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n# 3. Clustered Index\r\n---\r\n\r\n&nbsp;&nbsp;PRIMARY Key(기본 키)의 Index를 의미합니다. Primary Index가 아닌 Clustered Index인 이유는 **데이터의 물리적인 저장구조가 해당 인덱스를 기준으로 클러스터되어 저장**되기 때문입니다. 실제로 InnoDB는 모든 테이블의 데이터를 해당 테이블의 Clustered Index를 기준으로 정렬하여 해당 인덱스를 통한 조회에 최적화되어 저장합니다. <span class='small-text'>(이는 일반적인 인덱스의 역할과는 조금 다릅니다.)</span> 그러므로 **조회의 속도를 높이기 위해서는 Clustered Index를 설정하는 PRIMARY KEY를 자주 사용하는 트랜잭션의 유형에 따라 적절하게 설정하는 것이 중요**합니다. 실제로 단순히 인덱스 설정만으로도 조회에 대한 성능을 크게 향상할 수 있습니다.\r\n\r\n- Clustered Index는 제약조건이라는 하나의 '개념'이기 때문에 직접 설정하는 것이 아닌 Primary Key에 의해 설정됩니다.\r\n- 데이터를 삽입할 때, 인덱스에 대한 정보도 함께 저장해야 하기 때문에 삽입에 대한 성능은 (미비하게) 저하될 수 있습니다. 하지만 인덱스를 설정하여 오는 삽입의 성능 저하보다 조회의 속도 향상의 이점이 훨씬 높습니다.\r\n\r\n<br/>\r\n\r\n### PRIMARY KEY\r\n\r\n&nbsp;&nbsp;'기본 키'는 Clustered Index를 구성하는 컬럼의 집합입니다. 기본 키는 PRIMARY의 제약조건을 만족해야 하는데, 제약조건은 아래와 같습니다.\r\n\r\n- __기본 키의 컬럼들의 값은 모든 행을 구별할 수 있도록 유일한 값이어야 합니다. (UNIQUE INDEX)__\r\n- __여러 개의 컬럼으로 구성될 수 있으나, 구성되는 모든 컬럼은 NULL을 사용할 수 없다. (NOT NULL)__\r\n\r\n기본 키에 대한 추가적인 설명입니다.\r\n\r\n- **1. 모든 테이블에 대해 기본 키를 반드시 정의해야합니다.**  \r\n\r\n    &nbsp;&nbsp;이는 Clustered Index를 통한 데이터의 저장구조를 정의하기 위함입니다. 기본 키의 조건을 만족하는 컬럼이 존재하지 않으면 AUTO INCREMENT 컬럼을 생성하여 사용하는 것이 일반적입니다. 물론 기본 키를 설정하지 않으면 내부적으로 유일 키 중에서 제약조건을 만족하는 컬럼을 사용하거나 아예 보이지 않는 기본 키를 생성하여 사용하기도 합니다. \r\n\r\n<br/>\r\n\r\n- **2. 기본키를 컬럼의 갯수나 형식의 크기를 최소화하여 정의하는 것이 좋습니다.**\r\n\r\n    &nbsp;&nbsp;InnoDB는 모든 보조 인덱스에 기본 키의 컬럼을 추가하여 사용합니다. 이러한 특성으로 인해 기본 키의 크기가 클수록 보조 인덱스 또한 그 크기가 커지게 됩니다. 인덱스가 커질수록 쿼리의 성능 저하가 발생할 수 있기 때문에 기본 키를 최소화하여 정의하는 것이 중요합니다. 아래의 예제를 통해 기본 키와 보조 인덱스의 수행방식을 설명해보도록 하겠습니다.  \r\n    <br/>\r\n    ```SQL\r\n    CREATE TABLE t1 (\r\n    i1 INT NOT NULL DEFAULT 0,\r\n    i2 INT NOT NULL DEFAULT 0,\r\n    i3 INT NOT NULL DEFAULT 0,\r\n    d DATE DEFAULT NULL,\r\n    PRIMARY KEY (i1, i2),\r\n    INDEX k_d (d)\r\n    ) ENGINE = InnoDB;\r\n\r\n    INSERT INTO t1 VALUES \r\n        (1, 3, 10, '2021-07-13'),\r\n        (1, 4, 10, '2021-07-13'),\r\n        (6, 9, 11, '2021-07-13'),\r\n        (2, 4, 12, '2021-07-14'),\r\n        (3, 5, 12, '2021-07-11');\r\n\r\n    EXPLAIN SELECT * FROM t1 where d = '2021-07-13' and i1 = 1;\r\n    # +--------------------------------------------------------+ \r\n    # |       type       |         key         |      rows     |\r\n    # |---------------------------------------------------------\r\n    # |   index_merge    |     k_d, PRIMARY    |        2      |\r\n    # +--------------------------------------------------------+\r\n\r\n    EXPLAIN SELECT * FROM t1 where d = '2021-07-13' and i3 = 10;\r\n    # +----------------------------------------------------+ \r\n    # |     type   |     key     |   key_len  |    rows    |\r\n    # |-----------------------------------------------------\r\n    # |     ref    |     k_d     |      4     |      3     |\r\n    # +----------------------------------------------------+\r\n    ```  \r\n    <br>\r\n\r\n    &nbsp;&nbsp;`k_d` 인덱스의 키로 정의된 컬럼은 d뿐이지만, 기본 키의 컬럼과 인덱스의 컬럼을 함께 조건으로 사용하는 경우, 쿼리의 성능이 더 좋습니다. 반면에 기본키 컬럼을 조건으로 사용하지 않는 조회의 경우, `k_d` 인덱스만 사용합니다. 이 때, 인덱스의 길이인 `key_len`을 보면, 분명 `k_d` 인덱스의 키는 d컬럼으로, 인덱스 길이는 3(11일, 13일, 14일)이어야 합니다. 하지만 길이가 4인 것으로 볼 때, k_d 인덱스가 (d, i1, i2)를 키로 사용한 (d, i1)컬럼의 값인 (13, 1), (13, 6), (14, 2), (11, 3)으로 구성되어 있을 것으로 예상할 수 있습니다. \r\n\r\n\r\n### 이외의 인덱스 종류\r\n\r\n- **Secondary Index (보조 인덱스)**  \r\n  \r\n    &nbsp;&nbsp;Clustered Index이외의 모든 인덱스를 말합니다.\r\n\r\n<br/>\r\n\r\n- **UNIQUE INDEX**   \r\n\r\n    &nbsp;&nbsp;UNIQUE INDEX는 UNIQUE KEY(유일 키)를 통해 정의할 수 있으며 해당 인덱스는 모든 행을 구분할 수 있는 제약조건을 정의합니다. 제약조건은 아래와 같습니다.  \r\n\r\n    - __유일 키의 컬럼들의 값은 모든 행을 구별할 수 있도록 유일한 값이어야 합니다. (UNIQUE INDEX)__\r\n    - __단, NULL이 허용됩니다.__\r\n\r\n    유일 키는 NOT NULL의 제약조건이 추가되는 경우, 기본 키가 될 수 있습니다.\r\n\r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n# 4. FOREIGN KEY\r\n--- \r\n\r\n&nbsp;&nbsp;외래키는 **테이블 간의 데이터의 동일성 제약조건을 정의**하기 위해 사용됩니다. 외래키의 제약조건은 자식 테이블에서 외래키로 설정된 컬럼들의 값이 반드시 부모 테이블의 컬럼의 값을 사용하도록 강제합니다. 이를 통해 부모 테이블과 자식 테이블 간의 데이터 동일성을 만족하게 됩니다. 제품 - 주문 - 고객 테이블 예제를 통해 알아보도록 하겠습니다.\r\n\r\n\r\n```SQL\r\nCREATE TABLE product (\r\n    category INT NOT NULL, id INT NOT NULL,\r\n    price DECIMAL,\r\n    PRIMARY KEY(category, id)\r\n)   ENGINE=INNODB;\r\n\r\nCREATE TABLE customer (\r\n    id INT NOT NULL,\r\n    PRIMARY KEY (id)\r\n)   ENGINE=INNODB;\r\n\r\nCREATE TABLE product_order (\r\n    no INT NOT NULL AUTO_INCREMENT,\r\n    product_category INT NOT NULL,\r\n    product_id INT NOT NULL,\r\n    customer_id INT NOT NULL,\r\n\r\n    PRIMARY KEY(no),\r\n    INDEX (product_category, product_id),\r\n    INDEX (customer_id),\r\n\t\t\r\n\t\t# 외래키 정의\r\n    FOREIGN KEY (product_category, product_id)\r\n      REFERENCES product(category, id)\r\n      ON UPDATE CASCADE ON DELETE RESTRICT,\r\n\r\n    FOREIGN KEY (customer_id)\r\n      REFERENCES customer(id)\r\n)   ENGINE=INNODB;\r\n```\r\n\r\n&nbsp;&nbsp;위의 SQL문을 통해 테이블과 인덱스, 외래키까지 정의하였습니다. 테이블들의 관계를 ERD 다이어그램으로 그려보면 아래와 같이 그릴 수 있습니다.\r\n\r\n![](foreign_key_1.png)\r\n\r\n\r\n&nbsp;&nbsp;그림에서 주문 테이블(`product_order`)와 상품 테이블(`product`) `FK(1)`의 표현을 보시면 1: N 관계임을 알 수 있습니다. 자식 테이블인 주문 테이블의 (`product_category`, `product_id`) 컬럼의 값은 반드시 부모 테이블인 상품 테이블의 (`category`, `id`) 컬럼에 동일한 값이 존재해야 합니다. 두 테이블 간의 관계는 두 가지를 보장하게 됩니다.\r\n\r\n1. __주문한 제품이 없는 주문은 존재하지 않습니다.__  \r\n\r\n2. __모든 주문은 회사가 취급하는 제품(제품 테이블에 존재하는 제품)에 대한 주문입니다.__\r\n\r\n&nbsp;&nbsp;이러한 **추상적인 관계의 제약을 데이터베이스에 적용하기 위해** 외래키를 사용하는 것입니다. 외래키는 주문이 진행되어 주문 테이블의 행 삽입 시마다 외래키를 통해 제품 테이블의 컬럼값을 확인하는 과정을 거칩니다. 이 과정에서 위의 두 관계를 만족시키지 못하는 경우에는 데이터의 동일성을 유지하기 위해 행이 삽입되지 않습니다. 이와 마찬가지로 주문한 고객이 없는 주문은 있을 수 없기 때문에 `FK(2)`에 의해 주문 테이블의 `customer_id` 컬럼의 값은 반드시 고객(`customer`) 테이블의 `id` 컬럼에 동일한 값이 존재해야 합니다.  \r\n\r\n+ 여담으로, 제품 테이블의 기본 키를 (category, id) 순으로 사용하는 것으로 보아 제품 각각에 대한 조회보다 카테고리별 조회가 빈번하게 발생하는 경우라고 생각해볼 수 있겠습니다.\r\n\r\n\r\n<br/>\r\n\r\n### FOREIGN KEY 추가\r\n\r\n```SQL\r\nALTER TABLE child_tbl_name\r\n    ADD [CONSTRAINT [symbol]] FOREIGN KEY\r\n    [index_name] (col_name, ...)\r\n    REFERENCES parent_tbl_name (col_name,...)\r\n    [ON DELETE reference_option]\r\n    [ON UPDATE reference_option]\r\n\r\nreference_option:\r\n    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT\r\n```\r\n\r\n외래키의 추가는 자식 테이블에서 정의합니다.<span class='small-text'>(관계를 정의할 대상인 부모 테이블이 존재해야 하기 때문에 어찌 보면 당연합니다..)</span>\r\n\r\n- `CONSTRAINT [symbol]` 의 경우, 외래키 제약조건의 이름을 정의하기 위해 사용하며 생략할 수 있으나 이름을 통해 제약조건의 의미를 바로 알아볼 수 있도록 생략하는 것을 피하는 것이 좋습니다.  \r\n\r\n- *`reference_option`* 을 통해 제약조건에 의해 부모 테이블의 관계가 정의된 컬럼값의 수정, 삭제 시의 반영방식을 정의 할 수 있습니다.  \r\n\r\n  1. __CASCADE__  \r\n      부모 테이블의 컬럼 값의 수정, 삭제가 자식 테이블의 컬럼에도 동일하게 반영됩니다.   \r\n    <br/>\r\n  2. __SET NULL__  \r\n      부모 테이블의 컬럼 값의 수정, 삭제시 자식 테이블의 컬럼 값은 NULL을 가집니다.  \r\n    <br/>\r\n  3. __RESTRICT__  \r\n      수정, 삭제 시 InnoDB의 default 옵션으로, 외래키로 정의된 부모 테이블의 컬럼의 수정, 삭제하지 못하도록 막습니다. NO ACTION 옵션도 같게 동작합니다.  \r\n    <br/>\r\n\r\n<br/>\r\n\r\n### 사용시 장점\r\n\r\n&nbsp;&nbsp;외래키의 사용이 성능에 대한 이점을 가져다주지는 않습니다. 오히려 삽입 시마다 부모 테이블에 대해 존재 여부를 확인하는 과정을 거쳐야 하기 때문에 성능상 손해라고 볼 수 있습니다. 두 테이블을 외래키를 통해 조인하는 경우, 성능상의 이점을 가진다고 볼 수 있겠지만 이것은 외래키의 사용이 아닌 외래키의 생성 조건에 해당하는 '부모 테이블의 외래키에는 인덱스가 존재하여야 한다'에 의한 것입니다. 조인된 테이블에 대한 조회 시 해당 인덱스를 사용하기 때문입니다. 하지만 **테이블 간의 관계를 제약조건을 통해 데이터베이스가 데이터의 동일성을 유지함으로써 구현할 수 있고, 이는 곧 데이터 무결성을 보장**한다고 할 수 있겠습니다. \r\n\r\n<br/>\r\n\r\n### 사용시 유의사항\r\n\r\n&nbsp;&nbsp;하지만 이러한 제약조건을 만족하기 위해서는 유의해야 하는 것들이 있습니다. \r\n\r\n1. **외래키로 정의된 부모 테이블의 컬럼과 자식 테이블의 컬럼은 동일한 형식을 사용합니다.**  \r\n    <br/>\r\n2. **외래키로 정의된 부모 테이블의 컬럼은 반드시 인덱스가 필요합니다.**  \r\n    &nbsp;&nbsp;외래키 제약조건에 의해 자식 테이블의 행 삽입 시마다 부모 테이블의 외래키로 정의된 컬럼의 값에 대해 존재 여부를 확인해야 합니다. 이 과정을 테이블에 대한 조회가 아닌 인덱스를 사용한 조회를 통해 빠르게 수행하기 위해 외래키로 정의된 컬럼에 인덱스가 정의되어야 합니다. 부모 테이블에서 여러 컬럼을 외래키로 사용할 때도 동일하게 외래키로 정의된 맨 처음 컬럼에 대한 인덱스가 존재하여야 합니다.  \r\n    <br/>  \r\n3. **파티셔닝된 테이블에 대해서는 외래키를 사용할 수 없습니다.**    \r\n    <br/>\r\n   \r\n4. **자식 테이블의 외래키 컬럼 값은 반드시 부모 테이블의 외래키 컬럼에 존재하여야 합니다.**  \r\n    &nbsp;&nbsp;매우 당연한 이야기처럼 들리지만, 지켜지지 않는 경우가 꽤 있습니다. 예를 들어, 앞의 예제에서 아래의 ERD 다이어그램과 같이 카테고리만 따로 모아두는 테이블이 생성되었다고 생각해봅시다.\r\n\r\n    ![](foreign_key_2.png)\r\n\r\n    새로운 카테고리의 제품을 판매하려는 상황을 가정합니다. 이때 카테고리 테이블에 새로운 카테고리 삽입과 제품 테이블에 대한 새로운 카테고리의 물품 삽입을 동시에 실행하려고 하게 되면 간혹 카테고리 테이블에 삽입이 되기 전에 제품 테이블 삽입이 진행되면서 제약조건에 의해 삽입되어야 할 제품들이 누락되는 경우가 발생할 수 있습니다. (생각보다 쉽게 발생할 수 있습니다..)외래키 제약조건의 사용을 고려할 때에는 **반드시 부모 테이블에 대한 초기화가 선행되는 작업일 경우**에만 사용하거나 동시에 작업이 수행되지 않도록 예외처리를 해둬야 합니다.\r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n\r\n# 정리\r\n\r\n이번 포스팅에서는 InnoDB의 3, 4번 장점에 관해 설명하였습니다. 저번 포스팅과 동일하게 기능 구현에서 적용할 수 있는 것들을 정리해보겠습니다.\r\n\r\n### 3. Clustered Index\r\n\r\n- 해당 테이블에서 빈번하게 사용되는 트랜잭션의 조회조건을 파악하여 적합한 기본 키를 설정합니다.\r\n- 여러 개의 컬럼을 키로 사용하는 경우, 최소 조건이 되는 컬럼을 가장 빠른 순으로 정의합니다.\r\n\r\n### 4. FOREIGN KEY\r\n\r\n- 두 테이블 간 동일성이 유지되어야 하는 컬럼에 대해서 외래키를 사용합니다.\r\n- 조인이 필요한 테이블에 조인 기준 컬럼을 외래키로 정의합니다.\r\n\r\n\r\n\r\n# 참고자료\r\n\r\n[1] 인덱스와 테이블의 구조 이미지 [https://www.ibm.com/support/producthub/db2/docs.html](https://www.ibm.com/support/producthub/db2/docs/content/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0023327.html)\r\n\r\n[2] 외래키 [https://dev.mysql.com/doc/refman/5.6/en/create-table-foreign-keys.html](https://dev.mysql.com/doc/refman/5.6/en/create-table-foreign-keys.html)\r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n","excerpt":"InnoDB 주요 장점 동작을 수행하는 Commit, 동작 수행 이전 상태로 돌아가는 Rollback과 같은 Transaction 기능을 지원한다. Row-level locking과 Consistent reads를 통해 다중 사용자 환경에서 동시 수…","fields":{"slug":"/innodb-02/"},"frontmatter":{"date":"Jul 14, 2021","title":"MySQL의 엔진 InnoDB를 알아보자.(2/2)","tags":["DB","InnoDB","Index"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n\r\n&nbsp;&nbsp;스타트업 지원사업을 통해 데이터베이스 설계 및 유지보수 컨설팅을 받은 적이 있습니다. 멘토님과 이야기를 나누면서 DBA는 기본적으로 MySQL, MariaDB의 기본 엔진인 InnoDB에 대해 알아야 한다고 조언해주셨습니다. 엔진의 동작 원리에 따라 최적화 및 유지보수가 가능하기 때문인데요. 그래서 이번 포스팅은 MySQL docs에서 소개하고 있는 InnoDB의 장점을 자세히 설명하면서 필요한 주변 개념들도 함께 정리하고자 합니다. \r\n\r\n## InnoDB 주요 장점\r\n\r\n&nbsp;&nbsp;InnoDB는 MySQL 기본 저장 엔진입니다. MySQL docs에서 소개하고 있는 InnoDB의 주요 장점을 살펴보면,  \r\n1. __동작을 수행하는 Commit, 동작 수행 이전 상태로 돌아가는 Rollback과 같은 Transaction 기능을 지원한다.__\r\n2. __Row-level locking과 Consistent reads를 통해 다중 사용자 환경에서 동시 수행이 가능하다.__\r\n3. 물리적 저장 기준인 PRIMARY KEY를 통한 Clustered index 기능을 제공한다. \r\n4. 데이터 무결성을 보장하기 위한 FOREIGN KEY 기능을 제공한다.  \r\n\r\n&nbsp;&nbsp;이외에도 여러 가지 기능을 제공하지만 이번 포스팅은 주요 장점 1, 2번에 대해 다룰 것입니다. 1번부터 하나씩 살펴보겠습니다.\r\n\r\n\r\n# 1. Transaction 기능\r\n---\r\n\r\n&nbsp;&nbsp; Transaction(트랜잭션)이란, 데이터베이스에서 수행하는 작업의 가장 작은 단위를 말합니다. InnoDB는 모든 데이터베이스의 작업을 트랜잭션 단위로 묶어 수행하며, 트랜잭션이 ACID라고 불리는 특성을 만족할 수 있도록 기능을 제공합니다. ACID의 개념을 짧게 정리하면,\r\n\r\n### ACID\r\n\r\n- **A : Atomicity (원자성)**\r\n\r\n     트랜잭션의 작업은 분리될 수 없습니다. 만약 트랜잭션 내의 모두 작업이 수행되지 않으면 트랜잭션의 수행 이전 상태로 돌아가야 합니다.\r\n\r\n- **C :  Consistency (일관성)**\r\n\r\n    트랜잭션의 작업 이전, 이후 모두 데이터베이스의 무결성 제약조건을 만족해야합니다.\r\n\r\n- **I : Isolation (독립성)**\r\n\r\n    트랜잭션이 동시에 수행될 때, 각 트랜잭션 간의 수행이 서로에게 영향을 주지 않고 독립적으로 수행하게 됩니다. 해당 특성은 자원 점유에 대한 문제로, 성능을 위해 격리 수준을 조절할 수 있습니다.\r\n\r\n- **D : Durability(지속성)**\r\n\r\n    데이터 베이스의 무결성 제약을 위해 트랜잭션의 결과는 영속적으로 반영되어야 합니다.\r\n\r\n&nbsp;&nbsp;이러한 특성을 만족할 수 있도록 트랜잭션의 COMMIT, ROLLBACK 기능을 제공합니다. \r\n\r\n```SQL\r\n// autocommit은 세션 내에서 지정할 수 있습니다.\r\nSET autocommit = 0;\r\n\r\n// autocommit mode에서도 트랜잭션을 명시하여 사용할 수 있습니다.\r\nSTART TRANSACTION \r\n// 여러가지 SQL 문.\r\nCOMMIT\r\n```\r\n\r\n&nbsp;&nbsp;또한 SQL 쿼리문 각각이 하나의 트랜잭션으로 수행되는 ***autocommit* mode**를 제공합니다. 해당 모드에서는 사용자의 커넥션이 발생하였을 때, 새로운 세션을 시작하게 되고 각 쿼리문의 트랜잭션이 자동으로 커밋됩니다. 하지만 세션 내에서 트랜잭션의 에러가 발생하게 되면 해당 트랜잭션의 쿼리문의 수행이 ROLLBACK됩니다.  \r\n\r\n\r\n<br/>\r\n<br/>\r\n\r\n# 2. Consistent reads & Row-level locking\r\n---\r\n\r\n&nbsp;&nbsp;데이터베이스의 트랜잭션을 동시에 수행하기 위해서는 동일한 데이터를 동시에 조회하거나 수정/삭제하는 방식을 정의해야 합니다. 이러한 동시성 제어를 위해 **Consistent reads**와 **Row-level locking**를 사용합니다.\r\n\r\n\r\n## MVCC(Multi-Version Concurrency Control) 다중 버전 동시성 제어\r\n\r\n&nbsp;&nbsp;기본적으로 InnoDB는 **여러 시점에 버저닝된 스냅샷을 통해 동시성 제어를 수행**합니다. 스냅샷이란, 특정 시점의 데이터의 상태를 말합니다. 데이터를 조회하는 시점에 해당 데이터의 현재 상태를 미리 저장하여 두고 작업을 수행하는 방식으로, 여러 트랜잭션이 동시에 수행되더라도 각각 특정 시점의 데이터 상태를 기준으로 수정/삭제하기 때문에 동시성 제어가 가능하게 됩니다. 이후 각 스냅샷들 간의 변경을 데이터베이스에 반영하는 과정이 내부적으로 이루어집니다. 하지만 문제는 **트랜잭션 내에서 여러번의 조회가 발생하는 경우**입니다. 설명을 위해 MySQL docs의 예제를 가져왔습니다.\r\n\r\n```SQL\r\n               Session A              Session B\r\n\r\n           SET autocommit=0;      SET autocommit=0;\r\ntime\r\n|          SELECT * FROM t;\r\n|          #empty set\r\n|                                 INSERT INTO t VALUES (1, 2);\r\n|\r\nv          SELECT * FROM t;\r\n           #empty set\r\n                                  COMMIT;\r\n\r\n           SELECT * FROM t;\r\n           # (X)\r\n\r\n           COMMIT;\r\n\r\n           SELECT * FROM t;\r\n\t\t    # (Y)\r\n```\r\n\r\n&nbsp;&nbsp;예제는 두 개의 세션이 동일한 데이터에 대한 트랜잭션을 수행하고 있습니다. 세션 A가 3번째로 조회하는 시점에 세션 B가 트랜잭션이 COMMIT됨에 따라 데이터베이스에 반영되었습니다. 세션 A에서 3번째 조회 결과인 (X)는 두 가지가 될 수 있습니다.\r\n\r\n1. 트랜잭션 내부에서 사용되는 데이터베이스의 상태인 'empty set'  → **Repeatable Read**\r\n2. 세션 B가 수행한 트랜잭션이 반영된 현재 데이터베이스의 상태인 (1, 2) → **READ COMMITTED**\r\n\r\n이러한 **단일 트랜잭션 내의 여러 번의 조회 결과를 정의하는 방식**을 isolation level(격리 수준)로 정할 수 있는데요. 두 격리 수준에서 동시성 제어는 어떻게 이루어지는지 확인해보겠습니다.\r\n\r\n\r\n## Repeatable Read\r\n---\r\n\r\n&nbsp;&nbsp;innoDB의 격리 수준 중에서 기본설정에 해당하는 수준입니다. 번역하면 '반복 가능한 읽기'인데, 말 그대로 **동일 트랜잭션 내에서는 동일한 상태를 반복적으로 읽을 수 있다는 것**입니다. \r\n\r\n### 1) Consistent read\r\n\r\n&nbsp;&nbsp;트랜잭션 내에서 모든 작업은 최초로 읽은 데이터로 구성된 스냅샷을 사용하며, 트랜잭션이 커밋된 이후에만 새로운 스냅샷을 생성하여 사용합니다. 이를 통해 동일 트랜잭션에서의 모든 조회가 동일한 스냅샷을 보기 때문에 반복적인 읽기가 가능하게 됩니다. 그러므로 트랜잭션 내에서 여러 번의 조회를 수행하더라도 다른 트랜잭션이 삽입, 수정, 삭제한 작업의 결과가 데이터에 반영되지 않습니다. 위의 예제에서는 세션 A의 스냅샷을 사용하고 있기 때문에 세 번째 조회 결과 (X) 또한 세션 B의 수정이 반영되지 않은 'empty set'이 반환됩니다.\r\n\r\n- __트랜잭션의 시작 시점이 아닌 최초 SELECT 문을 통한 조회 시점에 스냅샷이 생성됩니다.__   \r\n    &nbsp;&nbsp;그러므로 최초의 SELECT 문을 수행하기 전 커밋된 다른 트랜잭션의 데이터 수정이 스냅샷에 반영됩니다.\r\n\r\n\r\n### 2) Row-level locking\r\n\r\n&nbsp;&nbsp;해당 격리 수준에서는 UPDATE, DELETE문을 위한 조회(수정하거나 삭제할 대상을 위한 조회)를 수행할 때 조회하는 조건 방식에 따라 다른 수정 / 삭제 작업인 UPDATE, DELETE문에 대한 잠금이 발생합니다. 모든 잠금은 트랜잭션이 커밋되는 시점에 해제됩니다.\r\n-  __UNIQUE Index를 사용할 수 있는 단일 값에 대한 조건을 가진 쿼리에 대해서는 해당 행에 대한 lock을 수행합니다.(Row-level locking)__   \r\n    &nbsp;&nbsp;쿼리문의 대상이 된 행에 대한 lock으로 인해 동시에 수정 / 삭제 작업이 수행되지 못하고 해제될 때까지 지연됩니다.\r\n- __이외에 방식의 조건의 경우, 조회에 사용된 모든 범위에 대한 lock을 수행합니다.(Gap locking)__   \r\n    &nbsp;&nbsp;조회 범위에 해당하는 행에 대한 잠금으로 인해 동시에 수정 / 삭제 작업이 수행되지 못하고 해제될 때까지 지연됩니다.\r\n\r\n<br/>\r\n\r\n## READ COMMITTED\r\n---\r\n\r\n&nbsp;&nbsp;격리 수준 중, Repeatable Read 다음 수준으로, **조회를 수행하는 시점에 커밋된 것을 읽는다는 것**을 의미합니다. \r\n\r\n### 1) Consistent read\r\n\r\n&nbsp;&nbsp;**조회 시점마다 새로운 스냅샷을 찍기 때문에 동일 트랜잭션 내에서도 다른 트랜잭션의 수정이 반영된 데이터를 조회**할 수 있게 됩니다. 위의 예제에서 매번 조회시마다 해당 시점의 최신 데이터로 스냅샷을 생성합니다. 세번째 조회 시점에는 이전에 커밋된 세션 B의 결과가 반영된 결과인 (1, 2) 행이 결과로 반환됩니다.\r\n\r\n### 2) Row-level locking\r\n\r\n&nbsp;&nbsp;Repeatable Read 격리 수준과 동일하게 UPDATE, DELETE문을 위한 조회(수정하거나 삭제할 대상을 위한 조회)를 수행할 때 조회하는 조건 방식에 따라 다른 수정 / 삭제 작업인 UPDATE, DELETE문에 대한 잠금이 발생합니다. 모든 잠금은 트랜잭션이 커밋되는 시점에 해제됩니다. \r\n\r\n- 하지만 다른 점은 __조회 범위에 대한 잠금이 아닌 수정을 수행할 행에 대해서만 잠금이 발생하게 됩니다.(Row-level locking)__  \r\n  &nbsp;&nbsp;조건으로 사용되지 않은 행에 대해서는 lock이 존재하지 않기 때문에 다른 트랜잭션의 UPDATE, DELETE가 수행되어 값이 즉시 반영되지만, 조건으로 사용된 행에 대해서는 lock이 해제되고 난 후에 수행됩니다. 이러한 잠금 방식은 동시성을 높이고 교착 상태를 피할 수 있게 합니다. 하지만 *Phantom Rows*가 발생할 수 있습니다. *Phantom Rows*에 대한 설명은 [해당 링크](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)를 참고하세요.\r\n\r\n<br/>\r\n<br/>\r\n\r\n### +) 격리 수준별 Row-level Locking\r\n\r\n&nbsp;&nbsp; 각 격리 수준의 행 수준의 잠금 차이를 이해하기 위해 MySQL doc의 예제를 설명하고자 합니다.\r\n\r\n- **1. 인덱스를 사용하지 않는 UPDATE / DELETE**  \r\n    <br/>\r\n    ```SQL\r\n    CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;\r\n    INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);\r\n    COMMIT;\r\n\r\n    # Session A\r\n    START TRANSACTION;\r\n    UPDATE t SET b = 5 WHERE b = 3;\r\n\r\n    # Session B\r\n    UPDATE t SET b = 4 WHERE b = 2;\r\n\r\n\r\n    EXPLAIN UPDATE t SET b = 5 WHERE b = 3;\r\n    # +------------------------------+ \r\n    # |      type     |      rows    |\r\n    # |-------------------------------\r\n    # |       ALL     |       5      |\r\n    # +------------------------------+\r\n    ```  \r\n      \r\n    &nbsp;&nbsp;예제에는 인덱스를 정의하지 않은  테이블 t가 존재합니다. 세션 A 쿼리문의 실행계획를 통해 조회한 행의 수는 5개로, 수정 작업을 위해 모든 행에 대한 조회가 발생했다는 것을 알 수 있습니다. **세션 A의 트랜잭션 수정 작업이 커밋되지 않은 시점에 동시에 세션 B의 수정 작업을 수행하고자 하는 상황**입니다. 각 격리 수준에 따라 수행 결과를 설명해보겠습니다.  \r\n\r\n    <br/> \r\n    \r\n    **Repeatable Read** \r\n\r\n    &nbsp;&nbsp;세션 A 쿼리문의 실행계획에서처럼 수정 작업의 조건을 만족하는 행을 찾기 위해서 모든 행을 조회하였습니다. 이때, 트랜잭션이 커밋되지 않았기 때문에 **조회를 사용한 모든 행에 대한 잠금이 발생**합니다. 이전 세션 A의 모든 행에 대한 잠금으로 인해 세션 B의 업데이트는 세션 A의 트랜잭션이 커밋될 때까지 지연됩니다.  \r\n    <br/>\r\n\r\n    **READ COMMITTED**\r\n\r\n    &nbsp;&nbsp;해당 격리 수준에서는 수정 작업의 조건을 만족하는 행을 찾기 위해서 조회한 행이 아닌 **실제 수정 작업을 수행하는 행에 대해서만 잠금이 발생**합니다. 세션 A를 통해서 UPDATE하지 않은 행 (1, 2) (5, 2)에 대한 잠금이 발생하지 않으므로, 세션 A의 트랜잭션이 커밋되지 않았음에도 세션 B의 수정이 즉시 이루어질 수 있습니다.\r\n\r\n<br/>\r\n<br/>\r\n\r\n- **2. 인덱스를 사용하는 UPDATE / DELETE**  \r\n    <br/>\r\n    ```SQL\r\n    CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;\r\n    INSERT INTO t VALUES (1,2,3),(2,2,4);\r\n    COMMIT;\r\n\r\n    # Session A\r\n    START TRANSACTION;\r\n    UPDATE t SET b = 3 WHERE b = 2 AND c = 3;\r\n\r\n    # Session B\r\n    UPDATE t SET b = 4 WHERE b = 2 AND c = 4;\r\n\r\n\r\n    EXPLAIN UPDATE t SET b = 5 WHERE b = 3;\r\n    # +---------------------------------------------------------+ \r\n    # |      type     |      possible_keys    |      rows       |\r\n    # |----------------------------------------------------------\r\n    # |     range     |            b          |        1        |\r\n    # +---------------------------------------------------------+\r\n    ```\r\n    <br/>\r\n\r\n    **Repeatable Read, READ COMMITTED**   \r\n    &nbsp;&nbsp; **인덱스를 사용하는 경우, 두 격리 수준 모두 수정 작업을 수행하는 행에 대해서만 잠금이 발생**합니다. 사실, Repeatable Read 수준에서는 작업을 수행하는 행에 대한 잠금이 발생한다고 해석하는 것보다는 수정 작업의 조건을 만족하는 행을 찾기 위한 조회가 Unique Index로 인해 작업을 수행하는 행에 대해서만 조회가 발생하고, 조회된 행에 대한 잠금이 발생한다고 보는 것이 맞습니다. 실제 Index가 존재할 때 세션 A의 UPDATE문의 실행계획을 보면 인덱스 b를 사용하여 1개의 행에 대한 조회가 발생한 것을 확인할 수 있습니다.\r\n\r\n<br/>\r\n<br/>\r\n\r\n\r\n# 정리\r\n이번 포스팅에서는 InnoDB의 1, 2번 장점에 관해 설명하였습니다. 장점에 대해 아는 것도 중요하지만 각 장점을 충분히 활용할 수 있도록 기능 구현에서 적용할 수 있는 것들을 정리해보겠습니다.  \r\n\r\n### 1. Transaction 기능\r\n\r\n- 반드시 함께 수행되어야 하는 쿼리들에 대해서는 트랜잭션으로 묶어서 사용하도록 합니다. 예를 들어 송금에 대한 기능 구현 시, A의 계좌에서 송금할 금액 차감, B의 계좌에 송금된 금액 가산, A에서 B로 송금한 로그 기록 등 하나라도 누락되어서는 안 되는 일련의 작업을 하나의 트랜잭션화하여 일관된 데이터 삽입이 가능하도록 구현합니다.\r\n- 트랜잭션 화 하여 수행하는 경우, 트랜잭션을 구성하는 작업 중 하나라도 에러를 반환하면, 해당 트랜잭션이 ROLLBACK되기 때문에 반드시 수행되지 않는 경우에 대해 에러 핸들링이 고려하여야 합니다.\r\n\r\n### 2. Row-level locking과 Consistent reads를 통해 다중 사용자 환경에 대한 동시성 제어\r\n\r\n- 수정 및 삭제 작업 시에 조회 조건을 인덱스를 기준으로 사용하여 행별 잠금으로 수행하도록 합니다. 이를 통해 해당 작업을 수행하지 않는 행에 대해서는 동시에 접근할 수 있도록 합니다.\r\n\r\n\r\n다음 포스팅에서는 InnoDB의 나머지 3, 4번 장점에 관해 설명하도록 하겠습니다.\r\n\r\n<br/>\r\n<br/>","excerpt":"스타트업 지원사업을 통해 데이터베이스 설계 및 유지보수 컨설팅을 받은 적이 있습니다. 멘토님과 이야기를 나누면서 DBA는 기본적으로 MySQL, MariaDB의 기본 엔진인 InnoDB에 대해 알아야 한다고 조언해주셨습니다. 엔진의 동작 원리에 따라…","fields":{"slug":"/innodb-01/"},"frontmatter":{"date":"Jul 13, 2021","title":"MySQL의 엔진 InnoDB를 알아보자.(1/2)","tags":["DB","InnoDB"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n&nbsp;&nbsp;지난 포스팅을 통해 JS에서 날짜 및 시간 데이터를 전달할 문자열은 ISO 8601 형식에 맞춰 사용하기로 하였다. 이제 이 문자열을 데이터베이스에 저장하고자 한다. 하지만 MySQL에서 사용할 수 있는 날짜 및 시간 데이터의 저장 형식은 5가지나 될뿐더러 각 형식에서 사용할 수 있는 문자열의 형식과 ISO 8601의 형식이 다르기 때문에 그대로 사용하기 어렵다. ISO 8601 형식의 문자열에 적합한 저장 형식을 고려하면서 이번 기회에 항상 헷갈렸던 MySQL의 날짜 및 시간 데이터 저장방식을 정리해보았다. <span class='small-text'>**관계형 데이터베이스의 데이터를 다루기 위해서 데이터베이스 관리 시스템(DBMS)을 사용하는데 그 중, MySQL을 기준으로 설명한다.</span>\r\n\r\n\r\n# MySQL의 날짜 및 시간 데이터 형식 (Data Type)\r\n\r\n&nbsp;&nbsp;MySQL은 날짜 및 시간 데이터를 5가지의 형식으로 저장한다. 각 형식에 대한 차이와 사용 가능한 문자열을 설명하고자 한다. <span class='small-text'>(숫자를 통한 표현도 가능하지만 여기서는 문자열 형식에 집중하였다.)</span>기본 예제는 '2020-03-20 03:30:58'을 사용한다.\r\n\r\n## 예제환경\r\n\r\n&nbsp;&nbsp;각 날짜 및 시간 데이터의 형식을 테스트하기 위해 각 형식의 컬럼을 가진 테이블을 생성하였다. 테이블의 DDL과 생성된 테이블의 컬럼을 아래에 제시하였다.\r\n\r\n```SQL\r\nDROP TABLE  IF EXISTS `type_test`;\r\n\r\nCREATE TABLE `type_test` (\r\n  `mytimestamp` timestamp,\r\n  `mydate` date,\r\n  `mytime` time,\r\n  `mydatetime` datetime,\r\n  `myyear` year\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\r\n```\r\n![](date_table.png)\r\n\r\n<br/>\r\n\r\n## DATE\r\n---\r\n\r\n&nbsp;&nbsp;날짜 정보를 저장한다. 사용 가능한 형식은 두 가지이다. 반드시 날짜의 의미를 가진 숫자를 사용해야 한다. \r\n### 1. 'YYYY-MM-DD' 의 형식 \r\n\r\n구분자를 사용한 년 - 월 - 일 데이터 형식이다. 아래와 같은 특징을 가진다. \r\n- __구분자 '-'에 대신 다른 특수 문자로 대체가 가능하다.__  \r\n  </br>\r\n- __년 / 월 / 일의 숫자 모두 날짜의 의미를 지니는 숫자여야 한다. 각각의 유효 범위는 아래와 같다.__  \r\n\r\n    ***(년 / 월 / 일 모두 0은 포함되지 않는다.)***\r\n\r\n    - 'YYYY'의 유효 범위는 [0001, 9999]\r\n    - 'MM'의 유효 범위는 [01, 12]\r\n    - 'DD'의 유효 범위는 [01, 31]\r\n\r\n```SQL\r\n# OK!\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-03-20');\r\n\r\n# OK!\r\nINSERT INTO `type_test` (mydate) VALUES ('2020%03%21');\r\nINSERT INTO `type_test` (mydate) VALUES ('2021~03~22');\r\n\r\n# Incorrect date value: '2020-03-32' for column 'mydate' at row 1\r\n# 32일은 날짜의 의미를 가지지 못한다.\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-03-32');\r\n\r\n# Incorrect date value: '2020-13-01' for column 'mydate' at row 1\r\n# 13월은 날짜의 의미를 가지지 못한다.\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-13-01');\r\n\r\n#Incorrect date value: '2020-01-00' for column 'mydate' at row 1\r\n# 년 / 월 / 일 모두 0은 사용이 불가능하다.\r\nINSERT INTO `type_test` (mydate) VALUES ('2020-01-00');\r\n```\r\n<br/>\r\n\r\n### 2. 구분자가 생략된 'YYYYMMDD' 형식\r\n위의 형식에서 구분자가 생략된 형식이다. 구분자를 사용하지 않기 때문에 문자열의 길이를 줄일 수 있으나 자릿 수에 따라 시간적 의미가 달라질 수 있으므로 주의하여야 한다.\r\n```SQL\r\n# OK!\r\nINSERT INTO `type_test` (mydate) VALUES ('20210320');\r\n\r\n# Incorrect date value: '20201301' for column 'mydate' at row 1\r\n# 13월은 날짜의 의미를 가지지 못한다.\r\nINSERT INTO `type_test` (mydate) VALUES ('20201301');\r\n\r\n# 2069-03-20이 저장된다.\r\nINSERT INTO `type_test` (mydate) VALUES ('690320');\r\n\r\n# 1970-03-20이 저장된다.\r\nINSERT INTO `type_test` (mydate) VALUES ('700320');\r\n```\r\n-  __네 자리 표현 'YYYY'으로 사용된 년도를 두 자리 표현 'YY' 이 사용 가능하다__  \r\n두 자리 표현은 표현 범위의 제약으로 필자는 사용하지 않는다. 사용하려면 [표현 범위 제약 조건](https://dev.mysql.com/doc/refman/8.0/en/two-digit-years.html)에 대해 올바르게 이해하고 사용하자. \r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n## TIME\r\n---\r\n&nbsp;&nbsp;시간 정보를 저장한다. 여러 가지 형식이 존재하지만, 기본적인 형식만 설명하고 이외의 형식은 예제로 소개만 하였다. DATE와 동일하게 반드시 시간의 의미를 가진 숫자를 사용해야 한다.\r\n\r\n### 1. 기본적인 시,분,초로 구성된 'hh:mm:ss' 형식\r\n\r\n구분자를 사용한 시:분:초 데이터 형식이다. 아래와 같은 특징을 가진다. \r\n\r\n- __시 / 분 / 초 각각의 유효 범위는 아래와 같다.__\r\n    - 'hh'의 유효 범위는 [00, 23]\r\n    - 'mm'의 유효 범위는 [00, 60]\r\n    - 'ss'의 유효 범위는 [00, 60]  \r\n    </br>\r\n- __기본 형식 'hh:mm:ss'에서 일의 수인 'D'를 추가하여 'D hh:mm:ss'를 사용할 수 있다.__     \r\n  &nbsp;&nbsp;&nbsp;&nbsp;'D'는 [0, 34] 사이의 값을 가지며, 1일당 24시간씩 더해져서 TIME 형식으로 저장된다.   \r\n  위의 예제에서는 4일이므로 24*4인 96시간이 더해져 99시간으로 저장된다.  \r\n    </br>\r\n- __부분 형식 또한 사용이 가능하다.__   \r\n그중 하나인 'hh:mm' 형식을 예제에서 확인할 수 있다.\r\n\r\n```SQL\r\n# 'hh:mm:ss' 형식, OK!\r\nINSERT INTO `type_test` (mytime) VALUES ('03:30:58');\r\n\r\n# Incorrect time value: '03:60:58' for column 'mytime' at row 1\r\nINSERT INTO `type_test` (mytime) VALUES ('03:60:58');\r\n\r\n# 'D hh:mm:ss' 형식, OK! '99:30:58'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('4 03:30:58');\r\n\r\n# 'hh:mm' 형식, OK! '03:30:00'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('03:30');\r\n```\r\n\r\n<br/>\r\n\r\n### 2. 구분자가 존재하지 않는 'hhmmss' 형식\r\n\r\n\r\n- 예제에서처럼 구분자가 존재하지 않는 문자열의 경우, 자릿수가 증가할수록 인식하는 형식이 달라지기 때문에 주의하여야 한다.\r\n\r\n```SQL\r\n# 'hhmmss' 형식, OK! '03:30:58'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('033058');\r\n\r\n# 'mmss' 형식, OK! '00:03:30'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('0330');\r\n\r\n# 'ss' 형식, OK! '00:00:08'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('8');\r\n\r\n# 'ss' 형식, Incorrect time value: '80' for column 'mytime' at row 1\r\nINSERT INTO `type_test` (mytime) VALUES ('80');\r\n\r\n# 'mmss' 형식, OK! '00:08:00'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('800');\r\n\r\n# 'mmss' 형식, Incorrect time value: '8000' for column 'mytime' at row 1\r\nINSERT INTO `type_test` (mytime) VALUES ('8000');\r\n\r\n# 'hhmmss' 형식, OK! '08:00:00'의 값을 가짐.\r\nINSERT INTO `type_test` (mytime) VALUES ('80000');\r\n```\r\n- <span class='sub-text'>** TIME 형식의 경우, 정밀도를 위해 소수 초를 지원한다. 'hh:mm:ss.fraction' 의 형식으로 최대 6자리까지의 소수를 지원하며 소수 초을 사용하기 위해서는 TIME 형식을 선언할 때, DATE(6) 과 같이 자릿수를 명시한다.</span>\r\n\r\n\r\n<br/>\r\n<br/>\r\n\r\n## DATETIME\r\n---\r\n&nbsp;&nbsp;날짜 및 시간 정보를 저장한다. 위의 DATE 형식과 TIME 형식을 함께 사용한 `'<DATE>T<TIME>'`의 형식을 사용한다. \r\n\r\n- __날짜와 시간을 'T'를 통해 구분하며, 구분자 대신 공백을 사용할 수 있다. `'<DATE> <TIME>'`__  \r\n    </br>\r\n- __`<DATE>`는 위의 DATE 형식의 설명과, `<TIME>`는 위의 TIME 형식의 설명과 동일하다.__  \r\n    \r\n    1. 년 / 월 / 일 / 시 / 분 / 초 모두 각 날짜와 시간의 의미를 가지는 유효 범위 내에 존재하여야 한다.  \r\n    2. 'YYYY-MM-DD hh:mm:ss', 'YYYYMMDDhhmmss', 'YYYYMMDDThhmmss' 의 형식이 사용가 능하다. (하지만 'YYYYMMDD hhmmss' 의 형식은 불가능하다.)\r\n    3. TIME 형식과 동일하게 소수 초를 지원하며 소수 초을 사용하기 위해서는 TIME 형식을 선언할 때, `DATETIME(6)`와 같이 자릿수를 명시한다.   \r\n   <br/>   \r\n\r\n- __오프셋의 명시가 가능하다.__    \r\n  \r\n    &nbsp;&nbsp;명시된 오프셋이 계산된 '2020-03-20 11:30:58'이 저장된다. TIMESTAMP 형식과 동일하게 시간대를 반영하여 저장되는데, 아래의 TIMESTAMP 형식의 설명을 통해 이해할 수 있다.  \r\n    <br/>\r\n\r\n- __위의 설명을 통해 DATETIME 형식에는 우리가 사용하고자 했던 '2020-03-20T03:30:58Z'은 삽입이 불가능하다는 것을 알 수 있다.__\r\n\r\n```SQL\r\n# 'YYYY-MM-DDThh:mm:ss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20T03:30:58');\r\n\r\n# 'YYYY-MM-DD hh:mm:ss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20 03:30:58');\r\n\r\n# ISO 8601 형식, Data truncation: Incorrect datetime value\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20T03:30:58Z');\r\n\r\n# 'YYYYMMDDThhmmss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('20200320T033058');\r\n\r\n# 'YYYYMMDD hhmmss' 형식, '2020-03-20 03:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('20200320 033058');\r\n\r\n# 오프셋 명시 형식,  '2020-03-20 11:30:58'\r\nINSERT INTO `type_test` (mydatetime) VALUES ('2020-03-20T03:30:58+01:00');\r\n```\r\n\r\n<br/>\r\n<br/>\r\n\r\n\r\n## TIMESTAMP\r\n---\r\n\r\n&nbsp;&nbsp;DATETIME과 동일하게 날짜 및 시간 정보를 저장하며 사용할 수 있는 문자열 형식 또한 \r\n`<DATE>T<TIME>` ,  `<DATE> <TIME>`으로 동일하다. 하지만 중요한 __두 가지 차이점__이 존재한다.\r\n\r\n### 1. 시간 의미의 차이\r\n\r\n&nbsp;&nbsp;전달되는 날짜 및 시간 문자열을 그대로 저장하는 DATETIME와 달리 TIMESTAMP 형식은 UTC 시간으로의 변환을 거친 뒤 저장한다. 이러한 변환 과정이 두 형식의 차이를 만드는데, 변환 과정을 '2020-03-20 03:30:58'로 예를 들어 설명한다.\r\n\r\n1. __데이터베이스의 환경변수로 설정된 time_zone(시간대)을 통해 해당 지역의 오프셋을 정의한다.__    \r\n   - 아래의 코드를 통해 현재 데이터베이스가 사용하는 시간대를 확인할 수 있다.\r\n    ```SQL\r\n    SELECT @@time_zone; // SYSTEM\r\n    SELECT @@system_time_zone; //KST\r\n    ```\r\n    </br>\r\n  \r\n   - `@@time_zone` 은 MySQL이 사용하는 시간대로, 'SYSYEM'의 값은 현재 시간대가 설정되지 않았으며, MySQL을 실행하는 OS의 시간대를 사용한다는 의미를 가진다. `SET @@time_zone = '+1';` 와 같이 SET을 통해 특정 시간대를 설정할 수 있다.  \r\n  <br/>  \r\n\r\n   - `@@system_time_zone`은 MySQL을 실행하는 OS의 시간대를 의미한다.\r\n\r\n    <br/>      \r\n\r\n2. __날짜 및 시간 데이터를 정의된 오프셋을 사용하여 UTC 시간으로 변환하여 저장한다.__   \r\n    \r\n   &nbsp;&nbsp;현재 데이터베이스가 사용하는 시간대가 'KST'이므로 오프셋은 '+9'이다.   \r\n   내부적으로는 '2020-03-20 03:30:58'으로 저장하는 것이 아닌,  \r\n    오프셋을 반대로 연산하여 변환된 UTC 시간인 '2020-03-19 18:30:58'UTC 로 저장된다.   \r\n    <br/>\r\n3. __조회 시에 현재 데이터베이스의 오프셋을 사용하여 UTC 시간으로 저장되어있는 날짜 및 시간 데이터를 지역 시간으로 바꿔 반환한다.__\r\n\r\n    &nbsp;&nbsp;TIMESTAMP 형식은 데이터 조회시마다 내부 변환 과정을 거친 데이터를 보여주기 때문에 일반적으로 DATETIME과 차이가 나지 않는다. 하지만 행 추가 시점과 조회 시점의 시간대가 변경되는 경우에 그 차이가 나타난다. 아래 코드의 결과를 통해 이해해보자.\r\n    ```SQL\r\n    DELETE FROM type_test;\r\n\r\n    // SYSTEM = KST = '+09:00'\r\n    SELECT @@time_zone; \r\n\r\n    INSERT INTO type_test(mydatetime, mytimestamp) \r\n    VALUES ('2020-03-20 03:30:58', '2020-03-20 03:30:58');\r\n\r\n    SELECT mydatetime, mytimestamp FROM type_test;\r\n    # +-------------------------------------------+\r\n    # |      mydatetime     |      mytimestamp    |\r\n    # |-------------------------------------------|\r\n    # | 2020-03-20 03:30:58 | 2020-03-20 03:30:58 |\r\n    # +-------------------------------------------+\r\n\r\n    SET @@time_zone = '+01:00';\r\n\r\n    SELECT mydatetime, mytimestamp FROM type_test;\r\n    # +-------------------------------------------+\r\n    # |      mydatetime     |      mytimestamp    |\r\n    # |-------------------------------------------|\r\n    # | 2020-03-20 03:30:58 | 2020-03-19 19:30:58 |\r\n    # +-------------------------------------------+\r\n    ```\r\n    <br/>\r\n    &nbsp;&nbsp;삽입 시점의 데이터베이스의 시간대는 KST으로, 오프셋은 '+9'이다. 시간대를 변경하기 전 조회 시점의 경우, 동일한 시간대, 동일한 오프셋이기 때문에 두 형식 모두 '2020-03-20 03:30:58'을 출력하는 것을 볼 수 있다. TIMESTAMP는 삽입 시점의 오프셋인 '+9'를 고려한 '2020-03-19 18:30:58'UTC 을 저장해두었다. 이후, 조회 시점의 오프셋 또한 '+9'로 동일하기 때문에 DATETIME과 동일한 '2020-03-20 03:30:58'을 반환한다. 하지만 시간대가 변경되고 난 후 TIMESTAMP 형식의 결과는 조회 시점의 시간대를 반영하기 때문에 '2020-03-19 18:30:58'UTC에 조회 시점의 오프셋인 '+1'을 연산한 '2020-03-19 19:30:58'을 반환하게 된다.  \r\n\r\n</br>\r\n\r\n### 2. 표현 범위의 차이\r\n\r\n&nbsp;&nbsp;두 번째 차이점인 표현 범위의 차이는 저장 방식의 차이이기도 한데, __TIMESTAMP는 UTC 시간으로 변환하여 저장할 때, 유닉스 시간으로 저장한다.__   \r\n\r\n___'유닉스 시간이란, UTC 시간의 시작시간인 '1970-01-01 00:00:00'UTC 로부터의 경과 시간을 UTC 초를 나타내는 4 바이트 정수를 의미한다.'___\r\n\r\n&nbsp;&nbsp;TIMESTAMP는 단순히 '2020-03-20 03:30:58'을 UTC 시간으로 변환한 '2020-03-19 18:30:58'UTC를 저장하는 것이 아닌, __'1970-01-01 00:00:00'UTC 부터 '2020-03-19 18:30:58'UTC 까지의 초 수인 $1,584,610,258$ 을 저장한다.__ 이러한 저장방식은 아래의 특징들과 같은 표현 범위의 차이를 만든다.\r\n\r\n\r\n- __유닉스 시간으로 저장되는 TIMESTAMP는 시작 시간인 '1970-01-01 00:00:00'UTC 에서부터만 표현이 가능하다.__   \r\n    &nbsp;&nbsp;&nbsp;&nbsp;UNIX_TIMESTAMP() 함수를 통해 유닉스 시간으로 변환해볼 수 있는데, '1970-01-01 00:00:00'UTC 이전의 날짜를 변환하면 모두 0의 값을 가진다.   \r\n\r\n    ```SQL\r\n    // 0\r\n    SELECT UNIX_TIMESTAMP('1970-01-01 00:00:00'); \r\n\r\n    // 1584610258\r\n    SELECT UNIX_TIMESTAMP('2020-03-20 03:30:58');\r\n\r\n    // 0\r\n    SELECT UNIX_TIMESTAMP('1945-08-15 00:00:00'); \r\n    ```\r\n    </br>\r\n- __TIMESTAMP는 4바이트 정수라는 한계로 인해 $2,147,483,647(2^{31}- 1)$ 초까지만 표현이 가능하다.__  (이를 'Y2K38', [2038년 문제](https://ko.wikipedia.org/wiki/2038%EB%85%84_%EB%AC%B8%EC%A0%9C)라고 한다.)  \r\n    &nbsp;&nbsp;&nbsp;&nbsp;실제로 유닉스 시간을 지역 시간으로 변환하는 함수인 `FROM_UNIXTIME()`으로 계산을 해보면 '2038-01-19 03:14:07'UTC, 한국 시각으로는 '2038-01-19 12:14:07'까지만 표현이 가능한 것을 확인할 수 있다. 표현 범위의 한계를 넘어선 2,147,483,648초를 변환해보면 NULL이 반환된다.  \r\n\r\n    ```SQL\r\n    // '2038-01-19 12:14:07', '2038-01-19 03:14:07'UTC\r\n    SELECT FROM_UNIXTIME(2147483647, '%Y-%m-%d %h:%i:%s');\r\n\r\n    // NULL\r\n    SELECT FROM_UNIXTIME(2147483648, '%Y-%m-%d %h:%i:%s');\r\n    ```\r\n    </br>\r\n\r\n&nbsp;&nbsp;DATETIME, TIMESTAMP의 표현 범위 차이를 정리하면,    \r\n  - __DATETIME은  &nbsp;&nbsp;&nbsp;['0000-01-01 00:00:00', '9999-12-31 23:58:59']__\r\n  - __TIMESTAMP는 ['1970-01-01 00:00:00', '2038-01-19 03:14:07']__  \r\n\r\n&nbsp;&nbsp;하지만 UTC 시간을 따르는 TIMESTAMP는 시간대에 따라, 명시한 오프셋에 따라 그 범위가 다르다.  \r\n또한 날짜 및 시간 데이터를 저장할 때는 표현 범위 밖의 데이터는 저장되지 않는다. 아래의 예제로 확인해보자.\r\n\r\n```SQL\r\n# Data truncation: Incorrect datetime value: '1970-01-01 00:00:01' for column\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('1970-01-01 00:00:00');\r\n\r\n# Data truncation: Incorrect datetime value: '1970-01-01 09:00:00' for column\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('1970-01-01 09:00:00');\r\n\r\n# OK! '1970-01-01 09:00:01'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('1970-01-01 09:00:01');\r\n\r\n# OK! '2020-03-20 11:30:58'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('2038-01-19 12:14:08+01:00');\r\n\r\n# OK! '2038-01-19 12:14:07'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('2038-01-19 12:14:07');\r\n\r\n# Data truncation: Incorrect datetime value: '2038-01-19 12:14:08'\r\nINSERT INTO `type_test` (mytimestamp) VALUES ('2038-01-19 12:14:08');\r\n```\r\n\r\n&nbsp;&nbsp;예제와 같이 __한국의 시간대를 사용하여 삽입할 때, 표현 범위는 지역의 오프셋을 고려한 범위인 ['1970-01-01 09:00:01', '2038-01-19 12:14:07']이 된다.__ 또한 오프셋을 명시한 '2038-01-19 12:14:08+01:00'도 가능한데, 위의 설명과 동일하기 때문에 '2020-03-20 11:30:58'의 값을 가지는 이유에 대해서는 스스로 이해해보자.\r\n\r\n</br>\r\n</br>\r\n\r\n# 결론\r\n\r\n## DATETIME vs TIMESTAMP\r\n---\r\n\r\n&nbsp;&nbsp;두 형식을 정리해보자면, \r\n  - 두 형식에 사용 가능한 문자열의 형식은 동일하며, 지역 지정자 'Z'가 추가된 문자열은 사용이 불가능하다.\r\n  - DATETIME은 __UTC를 고려하지 않고 지역 시간으로 저장__한다.\r\n  - TIMESTAMP는 __UTC를 반영하여 내부적으로 UTC 시간으로 저장해두고 조회 시에 지역 시간으로 변환한다.__ 이를 통해 조회하는 지역마다 동일한 UTC 시간을 의미할 수 있도록 다르게 표현한다.\r\n  \r\n<span class='small-text'>** 년도 정보를 저장하는 YEAR 형식도 존재한다. 자세히 다루지 않고 [링크](https://dev.mysql.com/doc/refman/8.0/en/year.html)로 대체한다.</span>\r\n</br>\r\n\r\n## ISO 8601 형식에 맞는 저장 형식은?\r\n---\r\n&nbsp;&nbsp;지금까지 MySQL에서 날짜 및 시간 데이터를 저장하는 형식에 대해 알아보았다. ISO 8601 형식의 데이터를 어떤 형식으로 저장해야할까? 날짜 데이터를 저장하는 DATE, 시간 데이터를 저장하는 TIME 두 형식 모두 날짜와 시간 데이터의 부분적인 정보만을 담을 수 있기 때문에 DATETIME, TIMESTAMP가 ISO 8601 형식의 데이터를 저장하는 데 적합하다고 볼 수 있다. ISO 8601 형식의 두 가지 경우에 따라 적합한 저장 방식과 전략을 설정해야 한다.\r\n\r\n### 'YYYY-MM-DDThh:mm:ssZ' 형식의 UTC 시간을 사용하는 경우,\r\n\r\n&nbsp;&nbsp;먼저 지역 지정자 'Z'가 추가된 문자열은 사용이 불가능하므로 제거하는 전처리가 필요하다.   \r\n1. DATETIME 형식으로 저장하게 되면 UTC 시간을 고려하지 않기 때문에 UTC 시간의 의미를 그대로 저장할 수 있으므로 __UTC 시간을 저장하길 원한다면 해당 형식을 사용하자.__  \r\n    </br>  \r\n2. TIMESTAMP에 저장하게 되면 해당 시간이 UTC 시간임에도 불구하고 지역 시간대를 고려한 UTC 시간으로 변환하는 작업을 거친 뒤, 저장되게 된다.~~(UTC 시간의 UTC 시간화..)~~   \r\n   &nbsp;&nbsp;&nbsp;&nbsp;물론 삽입과 조회 시점의 시간대가 동일한 경우, 저장한 시간의 값은 동일할 수 있으나 UTC 시간의 의미가 사라지게 된다. 또한 시간대가 변경되면 해당 시간대의 오프셋으로 계산되기 때문에 값이 변경될 수 있다. 그러므로 __TIMESTAMP를 사용하기 위해서는 '+00:00'으로 오프셋을 명시하여 UTC 시간으로 저장될 수 있도록 하자.__ \r\n\r\n</br>\r\n\r\n### 'YYYY-MM-DDThh:mm:ss' 형식의 지역 시간을 사용하는 경우, \r\n\r\n1. DATETIME 형식으로 저장하게 되면 UTC 시간을 고려하지 않기 때문에 지역 시간의 의미를 그대로 저장할 수 있으므로 __지역 시간을 저장하길 원한다면 해당 형식을 사용하자.__  \r\n    </br>  \r\n2. TIMESTAMP에 저장하게 되면 지역 시간대를 고려한 UTC 시간으로 변환하여 저장하기 때문에 조회하는 지역 시간대를 고려한 지역 시간대를 전달할 수 있다. __하지만 저장하고자 하는 지역 시간의 시간대와 데이터베이스의 시간대가 동일해야 올바른 시간을 전달할 수 있을 것이다.__\r\n\r\n\r\n</br>\r\n</br>\r\n\r\n## 참고자료\r\n---\r\n각 형식별 문자열 형식 [https://dev.mysql.com/doc/date-and-time-literals.html](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html)\r\n\r\n각 형식별 내부 저장 구조 [https://dev.mysql.com/doc/date-and-time-data-type-representation.html](https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html)\r\n\r\n</br></br></br>","excerpt":"지난 포스팅을 통해 JS에서 날짜 및 시간 데이터를 전달할 문자열은 ISO 8601 형식에 맞춰 사용하기로 하였다. 이제 이 문자열을 데이터베이스에 저장하고자 한다. 하지만 MySQL에서 사용할 수 있는 날짜 및 시간 데이터의 저장 형식은 5가지나 …","fields":{"slug":"/date-02/"},"frontmatter":{"date":"Jul 06, 2021","title":"MySQL에서 날짜 및 시간 문자열 저장하기","tags":["DB","DATE"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n&nbsp;&nbsp;날짜 관련 오류가 발생하면 그 때마다 원인을 이해하려고 하기보다 인터넷에서 코드를 긁어와 빠르게 해결하는 것에 집중했었다. \r\n하지만 이번 문제를 접하고, JS에서 날짜를 다루는 것에 대해 정리가 필요할 것 같아 포스팅하게 되었다. \r\n\r\n# 문제 \r\n\r\n&nbsp;&nbsp;Safari 환경에서 JS의 Date 객체를 사용하여 날짜를 보여주는 UI에서 _'Invalid Date'_ 를 뱉어냈다.\r\n\r\n![](invalid_date.png)\r\n\r\nSafari에서 'YYYY-MM-DD hh:mm:ss' (예를 들면 '2020-03-20 03:30:58') 형식의 문자열로 Date 객체를 선언하게 되는 경우 _'Invalid Date'_ 을 반환한다.\r\n\r\n\r\n### JS에서의 Date 객체\r\n\r\n&nbsp;&nbsp;JS에서는 Date 객체를 사용하여 날짜를 표현한다. 현재 시각이 필요한 경우, `new Date().now()` 를 통해 알아내기도 하고, 서버에서 전달받은 날짜 문자열을 `new Date(dateString)`으로 Date 객체를 만들어 시간/일자 연산(예를 들면, 호텔 체크아웃 날짜 계산)을 하는 등 문자열을 통해 날짜와 시간을 표현해야하는 경우에 쉽게 사용할 수 있다. 하지만 예상한 시간과 다르게 반환되거나 위의 경우처럼 아예 `NaN` 이 뜨는 등 갖가지 오류를 접하기도 하는데, 실제로 [Mozlia web docs](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/Date)를 보면 날짜 문자열 파싱 문제를 미리 경고해두었다.\r\n\r\n ___'Date 생성자(및 동일한 동작의 Date.parse())를 사용한 날짜 파싱은 동작이 일관적이지 못하고 브라우저끼리 차이가 존재하므로 사용하지 않는 것이 좋습니다.'___\r\n\r\n&nbsp;&nbsp;실제로 그런지 각 브라우저간의 차이를 확인하기 위해 Safari, Chrome, IE, Edge를 준비하고 각 브라우저의 콘솔창을 통해 결과값을 확인해보았다. ~~(Firefox, Opera 등 다른 웹 브라우저는 과제로 남겨두겠다.)~~ 테스트에 사용된 날짜 문자열  '2020-03-20 03:30:58'은 실제로 사용하고 있는 'YYYY-MM-DD hh:mm:ss' 형식의 dummy data이다.\r\n\r\n\r\n### 브라우저별 Date 객체 선언 테스트\r\n\r\n__1. 테스트 코드__  \r\n&nbsp;&nbsp; `new Date('2020-03-20 03:30:58')`\r\n\r\n#### 2. 테스트 결과   \r\n- safari - 버전 14.0.3(16610.4.3.1.7)\r\n![](safari_test1.png)\r\n<br/>\r\n\r\n- chrome - 버전 91.0.4472.114(공식 빌드) (arm64)\r\n![](chrome_test1.png)\r\n<br/>\r\n\r\n- edge - 버전 91.0.864.59 (공식 빌드) (64비트)\r\n![](edge_test1.png)\r\n<br/>\r\n\r\n- IE - 버전 2004(OS 빌드 19041.985)\r\n![](IE_test1.png)\r\n\r\n&nbsp;&nbsp;동일한 날짜 문자열의 Date 객체를 선언하였음에도 그 결과가 브라우저마다 다른 것을 볼 수 있다. <span class='sub-text'> (**브라우저의 실행 지역, 버전에 따라 결과가 다를 수 있습니다.)</span> 이 테스트를 통해 JS가 수행되는 환경에 따라 Date 객체를 통한 파싱의 결과가 다를 수 있다는 것을 알 수 있었다. 그럼에도 불구하고 서버 측에서 날짜 및 시간에 대한 데이터를 문자열 형태로 전달하기 때문에 브라우저상에서 Date 객체를 통해 날짜를 파싱하는 것이 불가피하였다. 그래서 각기 다른 브라우저에서 동일한 파싱 결과를 보여줄 수 있는 다른 방법을 찾아보았다.\r\n\r\n\r\n# 원인 \r\n\r\n&nbsp;&nbsp;하지만 실제 문제의 원인은 날짜 및 시간 데이터의 전달을 위해 내부적으로 사용하던 'YYYY-MM-DD hh:mm:ss' 형식이 날짜 및 시간 문자열 표준 형식인 ISO 8601을 따르지 않은 것이다. 이로 인해 특정 브라우저에서 날짜에 대한 데이터로 인식되지 못하는 문제가 발생했다. 문제를 해결하기 위해서는 날짜 및 시간 문자열의 표준 형식인 ISO 8601의 개념이 필요하기에 나름대로 요약해보았다. 내가 필요한 부분만 가져왔기 때문에 깊게 알고 싶은 분들은 출처를 참조하자.\r\n\r\n### ISO 8601\r\n> ISO 8601은 날짜와 시간과 관련된 데이터 교환을 다루는 국제 표준이다.\r\n- 날짜표현은  `YYYY-MM-DD` , 시간 표현은 `hh:mm:ss.sss` `hh:mm:ss` 으로 표현되며 구분자는 생략이 가능하다.\r\n- 날짜와 시간 혼합표현은 `<date>T<time>`이다.\r\n- 날짜와 시간은 0을 붙여 고정 자릿수를 유지한다.\r\n- 시간이 UTC인 경우, 시간 뒤에 빈칸없이 Z를 직접 추가해야 한다. Z는 오프셋이 0인 UTC를 위한 지역 지정자(zone designator)다.  `<date>T<time>Z` 가 된다.\r\n\r\n___'인터넷 상에서, World Wide Web Consortium (W3C)는 에러율과 소프트웨어 복잡도를 줄이기 위해 제공된 날짜와 시간 형식을 제한하는 표준 프로파일을 정의하기 위해 ISO 8601를 사용한다.'___\r\n\r\n&nbsp;&nbsp;날짜 및 시간 문자열 형식을 표준에 맞추기 위해서는 'YYYY-MM-DD hh:mm:ss'가 아닌 'YY-MM-DDThh:mm:ssZ' 의 형식을 사용해야 한다. 단순히~~(무지성으로)~~ 날짜와 시간 사이에 'T'를 넣고 맨 마지막에 'Z'가 붙여 표준 형식을 맞추려고 했다면 전혀 다른 날짜 및 시간 정보를 보게 될 것이다. 브라우저가 ISO 8601 문자열로 Date 객체를 생성할 때, __'Z' 문자를 통해 해당 문자열이 표현하는 시간을 오프셋이 0인 UTC 시간으로 인식하기__ 때문이다. 대신, 맨 뒤의 __'Z' 문자를 빼게 되면 해당 문자열이 표현하는 시간을 UTC 시간이 아닌 지역 시간으로 인식하게__ 된다. 갑자기 등장하는 'UTC', '오프셋', '지역 시간'의 개념이 생소할 수 있다. 아래에서 간단히 설명하는데 혹시 자세히 알고 싶다면 [위키](https://ko.wikipedia.org/wiki/%ED%98%91%EC%A0%95_%EC%84%B8%EA%B3%84%EC%8B%9C)를 참조하자.\r\n\r\n- **UTC**\r\n    > GMT(그리니치 평균 시간)로도 불리며, 그리니치 천문대의 시간을 기준으로한 국제 표준시이다.\r\n<br/>\r\n\r\n- **오프셋**\r\n    > 그리니치 천문대의 시간을 기준으로 한 GMT와 지역별의 시간차이를 의미한다.\r\n    - <span class=\"small-text\"> 한국은 +9으로, 즉 그리니치 천문대의 시간보다 9시간이 빠르다.</span>  \r\n<br/>  \r\n\r\n- **지역 시간**\r\n    > GMT를 기준으로 해당 지역의 오프셋, 썸머 타임등을 반영한 시간이다.\r\n    - <span class=\"small-text\"> 현재 이 글에서는 서비스 사용자의 브라우저가 실행되는 지역의 시간을 의미한다. </span>\r\n    - <span class=\"small-text\">  **쉬운 설명을 위해 오프셋에 썸머타임 등, 지역시간에 영향을 주는 변수를 모두 포함하겠다. </span>\r\n\r\n글만으로는 이해하기 어려울 것 같아 각 브라우저, 문자열 형식별 비교를 위해 3개의 코드를 각 브라우저에서 실행시켜보았다. 결과를 보면서 이해해보자.\r\n\r\n### 브라우저/형식별 Date 객체 선언 테스트\r\n\r\n#### 1. 테스트 코드\r\n\r\n1-1. 이전 테스트  \r\n  &nbsp;&nbsp; `new Date('2020-03-20 03:30:58')`  \r\n\r\n\r\n1-2. 단순히 형식을 맞추기 위한 'T', 'Z' 문자 추가  \r\n  &nbsp;&nbsp; `new Date('2020-03-20T03:30:58Z')`  \r\n\r\n1-3. 지역 시간으로 전달하기 위해 'Z' 제거  \r\n  &nbsp;&nbsp; `new Date('2020-03-20T03:30:58')`  \r\n\r\n#### 2. 테스트 결과\r\n- safari - 버전 14.0.3(16610.4.3.1.7)\r\n![](safari_test2.png)\r\n<br/>\r\n\r\n- chrome - 버전 91.0.4472.114(공식 빌드) (arm64)\r\n![](chrome_test2.png)\r\n<br/>\r\n\r\n- edge - 버전 91.0.864.59 (공식 빌드) (64비트)  \r\n![](edge_test2.png)\r\n<br/>\r\n\r\n- IE - 버전 2004(OS 빌드 19041.985)\r\n![](IE_test2.png)\r\n\r\n\r\n&nbsp;&nbsp;`new Date('2020-03-20T03:30:58Z')`의 결과를 살펴보면 한국의 시간 오프셋은 +9이기 때문에 'T', 'Z' 문자가 추가된 Date 객체의 시간은 03시가 아닌 9시간이 더해진 12시가 된다. 하지만 'T' 문자만 추가한 `new Date('2020-03-20T03:30:58')`의 결과에서는 오프셋을 계산할 지역 정보가 존재하지 않기 때문에 지역 시간으로 간주하여 시간이 03시 그대로인 것을 볼 수 있다.\r\n\r\n# 해결\r\n\r\n&nbsp;&nbsp;이번 문제는 날짜 및 시간의 문자열을 표준 형식으로 맞추는 것으로 문제를 해결할 수 있다. 해결하는 방법은 기준 시간대를 UTC 시간으로 할 것인가, 지역 시간으로 할 것인가에 따라 두 가지로 나뉜다. 이해를 돕기 위해 글의 작성시점인 한국 시각 '2021-06-30 13:49:30'를 예로 들어 설명하고자 한다.\r\n\r\n### 1. UTC 시간을 기준으로 포맷팅\r\n\r\n__'기존의 시간에서 지역의 시간 오프셋을 반대로 연산하여 UTC 시간으로 바꿔 전달하여 브라우저가 사용자의 지역시간에 맞게 변경할 수 있도록 한다.'__  \r\n\r\n&nbsp;&nbsp; UTC 시간을 기준으로 전달하기 위해 '2021-06-30 13:49:30'을 한국의 오프셋인 '+9'를 고려하여 9시간을 뺀 '2021-06-30T04:49:30'UTC 로 미리 계산, 포맷팅하여 데이터 베이스나 서버의 내부 데이터로 사용하는 방법이다. __브라우저는 '2021-06-30T04:49:30Z'의 문자열로 Date 객체를 생성할 때 해당 시간을 UTC 시간으로 인식하고 브라우저가 실행되는 지역에 맞게 지역 시간으로 변경한다.__ 한국의 브라우저에서는 9시간이 더해진 '2021-06-30 13:49:30'으로 표현될 것이고, 오프셋이 '+1'인 프랑스의 브라우저에서는 '2021-06-30 05:49:30'으로 표현될 것이다. 이를 통해 지역별 시간대 변환 문제를 해결할 수 있다. 하지만 __지역 시간으로 변경하는 연산을 브라우저에게 의존해야 하기 때문에__ 예기치 않은 문제가 발생할 수 있다는 단점이 있다.<span class='sub-text'>(브라우저 종류, 버전에 따라 달라질 수 있다고 한다.)</span> 또한 국내 시간대만 사용하는 서비스의 경우, 지역 오프셋을 미리 계산하는 포맷팅 과정이 불필요할 수 있다.\r\n\r\n<br/>\r\n\r\n### 2. 지역 시간을 기준으로 포맷팅\r\n\r\n__'지역 시간을 기준으로 전달하기 위해 '2021-06-30 13:49:30'을 '2021-06-30T13:49:30'로 변환하여 데이터 베이스나 서버의 내부 데이터로 사용하는 방법이다.'__\r\n\r\n&nbsp;&nbsp; 지역 시간을 기준으로 전달하기 위해 '2021-06-30 13:49:30'을 '2021-06-30T13:49:30'로 변환하여 데이터 베이스나 서버의 내부 데이터로 사용하는 방법이다. 위의 방법과 달리 __브라우저는 '2021-06-30T13:49:30'의 문자열로 Date 객체를 생성할 때 해당 문자열을 지역 시간으로 인식하고 그대로 '2021-06-30 13:49:30'을 표현한다.__ 국내 시간대만 사용하는 서비스의 경우에는 지역 시간만 사용해도 되기 때문에 바로 적용 가능한 방법이다. __하지만 동일 시간대를 사용하지 않는 다른 지역에서의 접속 시 문제가 발생한다. 해당 지역의 오프셋을 고려하지 않기 때문에 프랑스의 브라우저에서도 동일하게 '2021-06-30 13:49:30'으로 표현된다.__ 같은 시간이 _\"표시됐으니 된 거 아냐?\"_ 할 수 있지만, 전혀 다른 의미를 가진다. 프랑스 브라우저의 시간을 한국 시각으로 계산해보면,   \r\n\r\n1. <span class='small-text'>'2021-06-30 13:49:30'을 UTC 시간으로 변경하면 -1 시간을 한 '2021-06-30 11:49:30'이 된다. </span> \r\n  \r\n2. <span class='small-text'> '2021-06-30 11:49:30'을 한국 시간으로 변경하면 +9 시간을 한 '2021-06-30 20:49:30'이 된다.</span>   \r\n\r\n프랑스의 브라우저가 나타내는 시간은 전혀 다른 '2021-06-30 20:49:30'을 의미하고 있는 것이다! 한국의 브라우저에서는 내가 점심을 먹고 글을 작성하였다면, 프랑스의 브라우저에서는 저녁을 먹고 글을 작성한 것이 된다. 이처럼 여러 시간대의 글로벌한 서비스를 위해서는 단순히 지역 시간으로 제공하는 것이 아닌   '2021-06-30T13:49:30+9',  '2021-06-30T13:49:30+1'과 같이 문자열 끝에 해당 지역의 오프셋을 명시하는 방법을 사용해야 한다. 사실 Date 객체의 `toLocaleString()` 함수를 사용하여 지역 시간대로 변경할 수 있다고 하지만 이 글에서는 문자열에만 집중해보았다.\r\n\r\n<br/>\r\n\r\n### 3. 날짜 관련 라이브러리 사용\r\n\r\n&nbsp;&nbsp;위의 두 가지의 해결 방식은 라이브러리의 사용을 고려하지 않았다. 하지만 라이브러리는 문자열의 형식이나 오프셋 계산등 걱정하지 않고 사용할 수 있도록 많은 기능이 제공된다. 사실상 지금까지의 모든 고민을 해결할 수 있으니 나처럼 고민하지 말고 그냥 사용하자. 추천하는 라이브러리는 _day.js_ 인데 대문부터 크기를 강조하는 것을 보면 다른 날짜 라이브러리보다 가벼운 것은 확실해 보인다. (가벼운 게 최고다.) 함수명이 매우 직관적이라 쉽게 사용할 수 있기 때문에 설명하지 않고 예제와 [docs](https://day.js.org/docs/en/installation/installation) 링크를 남긴다.\r\n\r\n```javascript\r\n// 대충 한국 시간대를 사용하겠다는 코드\r\nimport dayjs\r\nimport LocalizedFormat from 'dayjs/plugin/localizedFormat';\r\nimport relativeTime from 'dayjs/plugin/relativeTime';\r\nimport 'dayjs/locale/ko';\r\n\r\ndayjs.extend(LocalizedFormat);\r\ndayjs.extend(relativeTime);\r\n\r\ndayjs(date).toISOstring()\r\n```\r\n<br/>\r\n\r\n# 요약\r\n\r\n- Date 객체를 사용하여 날짜 및 시간 문자열을 파싱하기 위해서는 표준인 ISO 8601을 따르자. 그래야 브라우저별로 다르게 동작하는 것을 ~~(거의 다)~~ 막을 수 있다.  \r\n   \r\n- 시간대별로 브라우저의 동작이 다를 수 있으니 서비스에 따라 'UTC 시간', '지역 시간' 또는 '오프셋을 명시한 지역시간' 중 적절한 형식을 사용하자.  \r\n  \r\n- 그냥 날짜 관련 라이브러리를 사용하자.\r\n\r\n다음 포스팅에서는 Node.js(NestJS) - MySQL 데이터 베이스에서 날짜 및 시간 문자열을 다루는 것을 정리해보려고 한다. MySQL에서 날짜 및 시간 문자열을 다루는 형식은 또 다르다. 다음 글은 좀 짧으니 시간이 남는다면 읽어보자.\r\n\r\n### 참고 자료\r\n\r\n시간 및 날짜 문자열에 대한 정리 [https://meetup.toast.com/posts/130](https://meetup.toast.com/posts/130)  \r\nISO 8601에 대한 정의 [https://ko.wikipedia.org/wiki/ISO_8601](https://ko.wikipedia.org/wiki/ISO_8601)\r\n\r\n<br/><br/><br/><br/>\r\n","excerpt":"날짜 관련 오류가 발생하면 그 때마다 원인을 이해하려고 하기보다 인터넷에서 코드를 긁어와 빠르게 해결하는 것에 집중했었다. \n하지만 이번 문제를 접하고, JS에서 날짜를 다루는 것에 대해 정리가 필요할 것 같아 포스팅하게 되었다.  문제   Safa…","fields":{"slug":"/date-01/"},"frontmatter":{"date":"Jul 02, 2021","title":"JS에서 날짜 및 시간 문자열 다루기","tags":["JS","DATE"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}